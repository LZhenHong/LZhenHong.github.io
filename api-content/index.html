{"posts":[{"title":"C# 扩展方法","content":"为什么想要把 C# 的方法扩展单独拿出来讲一下呢？ 因为当我们学习一门新的编程语言时，很多时候都会拿这门编程语言跟我们熟悉的编程做对比。因为编程语言的设计者不同，编程思想和理念是存在很多差别的，就算是同样相同的面向对象的编程语言，也会在细节上存在各种差异。 我个人的编程经历是从 C 语言入门，然后就开始学习 Objective-C，在随后很长一段时间里都是和 OC 打交道，作为第一门面向对象的编程语言，OC 很大程度上影响了我的编程习惯和风格，以至于在学习其他编程语言时都会跟 OC 做对比，或者代入 OC 的编程习惯。 当我在 C# 中看到扩展方法时，很快就联想到 OC 里面的类扩展。他们都可以在不修改类源码的前提下，扩展类的实例方法，但是在实现方式上存在差异。因此想简单记录下 C# 的扩展方法使用以及与 OC 类扩展的异同点。 扩展实现 先了解一下 C# 中如何实现扩展方法： using System; using System.Security.Cryptography; using System.Text; namespace Extension { public static class StringExt { /// &lt;summary&gt; /// 将字符串转换成 MD5 /// &lt;/summary&gt; /// &lt;returns&gt;加密后的 MD5 值&lt;/returns&gt; public static string MD5(this string text) { var md5 = new MD5CryptoServiceProvider(); byte[] bytes = md5.ComputeHash(Encoding.UTF8.GetBytes(text)); string md5Hash = BitConverter.ToString(bytes).Replace(&quot;-&quot;, &quot;&quot;).ToLower(); return md5Hash; } } } 这种方式看起来的和我们自定义普通的静态工具类看起来没有什么区别，但是注意在方法的参数前面有一个 this 的修饰词，这个 this 关键字就是 C# 定义扩展方法的魔法。 如果没有 this 关键字，我们调用这个 MD5 方法的方式是 StringExt.MD5(str); 这样的。 在加上了 this 关键字之后，我们就可以像调用 string 的实例方法一样去调用 MD5 方法 str.MD5();，同样我们也可以像上面一样方式 StringExt.MD5(str); 调用。这样的调用方式看起来更符合直觉，对字符串进行 MD5 就应该像是字符串的实例方法。 扩展接口 如果我们需要为 C# 写一些工具类方法，扩展方法是很理想的实现方式。但是扩展方法的使用场景更强大，上面举的例子是针对于特定的类实现的扩展方法，但是扩展方法还可以针对于接口。例如： System.Linq.Enumerable 中有很多对接口 IEnumerable&lt;T&gt; 的扩展方法 (Where/SortBy/ThenBy 等)。 下面的例子来自《Effective C#》P125： public static class Comparable { public static bool LessThan&lt;T&gt;(this T left, T right) where T : IComparable&lt;T&gt; =&gt; left.CompareTo(right) &lt; 0; } 这里示例是扩展 IComparable 接口，所有实现 IComparable 接口类的实例都可以使用 LessThan 方法，这个就是扩展方法强大的地方。虽然没有 Swift 扩展那么强大，但是也足够我们在扩展类的方法上有了另一种选择。 用扩展的方式来扩充类方法是最好的实践，我们可以利用 namespace 来区分不同分类的扩展方法。例如：把排序相关的扩展方法放在 Sort 命名空间下，把转换相关的扩展方法放在 Transform 命名空间下，这样使用者就是根据自身的需求来引入不同的命名空间，来扩展现有类的实例方法。在扩展方法的支持下，我们把一个类的实现分成基础类加上不同分类的扩展方法，这样的实现方法可以减少对原始类的修改或者编写新的派生类。 注意点 扩展方法的实现方法是因为 C# 编译器在编译过程中生成的中间语言 (IL) 会将扩展方法的实例调用转换成对静态方法的调用。所以 str.MD5(); 在经过编译器编译之后与 StringExt.MD5(str); 是没有区别的。 当了解了编译器的实现扩展方法的方式之后，我们对扩展方法的特点也可以描述出来。 可以利用扩展方法为枚举类型编写方法。 如果扩展方法是针对于值类型，因为值类型的参数传递是复制，在扩展方法中的修改不会影响原始值，可以使用 ref 关键字解决。 不能重写扩展方法 ，当有多个相同方法签名的扩展方法时，C# 编译器会选择第一个被找到的扩展方法。 如果扩展方法与该类型中定义的方法具有相同的方法签名，C# 编译器在编译过程中选择方法实现时会优先选择类型中定义的方法，扩展方法不会被调用。 不能访问类型中的私有变量，这个跟静态方法的限制是一样的。 相关链接 扩展方法（C# 编程指南） 如何实现和调用自定义扩展方法（C# 编程指南） 《Effective C#》第 27 条、第 28 条 ","link":"https://lzhenhong.github.io/post/c-kuo-zhan-fang-fa/"},{"title":"Promise 与动画","content":"学习编程语言的过程都是相似的，先介绍语言基础类型、流程控制、函数格式等。编程的过程基本上就是流程的控制，判断状态，执行不同的逻辑，类、对象、方法是行为的封装。我们在刚接触编程会写很多 if-else、switch，为了减少 if-else 和 switch 的使用，会有继承、设计模式的应用。 在流程控制中有一种特别的存在，就是异步处理，在我个人的编程生涯很长一段时间里都是以回调或者委托的方式处理。回调的方式可以把逻辑写在一处，同时可以很轻松得到异步处理的上下文，但是多个异步处理的情况就会导致回调地狱。委托的方式则会把回调逻辑分开，上下文需要另外维护。 如何控制好异步处理的逻辑是很重要的，回调方式和委托的方式大部分情况下都不是最优解。现在有更好的 Promise 解决方案，再结合 async/await 的语法糖，让我们得以以同步的方式来处理异步逻辑，更好控制异步逻辑的流程。 Promise 真的是一学就后悔，后悔学晚了。 Promise 简介 Promise 可以很方便对异步操作进行封装。Promise 提供的链式接口可以很便捷顺序组装、合并组装异步操作。 function main() { requestData((isSucc, data, error) =&gt; { if (isSucc) { console.log(data); } else { console.error(error); } }); } function requestData(complete: (isSucc: boolean, data?: any, error?: any) =&gt; void) { sendRequest((data) =&gt; { complete(true, data) }, (error) =&gt; { complete(false, null, error); }); } function sendRequest(success: (data: any) =&gt; void, failure: (error: any) =&gt; void) { // Send request to server. // 伪代码 if (succ) { success(data); } else { failure(error); } } 这里以一个简单的网络请求为例，网络请求是程序开发中最常见的异步操作。这种回调方案是刚接触编程常用的处理方式。这种方式看起来也没有太大的问题，把网络请求的结果处理另外封装成单独的函数，看起来也是很简洁的。但是这样我们在处理多个异步操作时，就会发现我们要理顺异步操作的流程，就需要不停的在回调里跳转。如果不把处理异步处理封装成单独的函数，就会出现回调地狱的情况。 下面来看 Promise 的解决方案。 function main() { requestDataAsync().then(console.log, console.error); } function requestDataAsync(): Promise&lt;any&gt; { return new Promise((resolve, reject) =&gt; { sendRequest((data) =&gt; { resolve(data); }, (error) =&gt; { reject(error); }) }); } function sendRequest(success: (data: any) =&gt; void, failure: (error: any) =&gt; void) { ... } Promise 的解决方案跟异步回调的处理方式貌似没有太大的区别，但是这只是一个异步处理，如果有多个异步处理，Promise 是可以直接在 then 方法里返回下一个异步处理的 Promise ，这样异步处理就可以顺序执行。 在异步处理的流程里，Promise 可以清晰表明每一步异步处理。可以很方便调整异步处理的顺序，也可以快速新增或删除某一个异步处理，这是在回调方式中难以办到的。 动画的回调 程序为了给用户更好的体验和表现，会在程序中加入很多动画以优化程序表现和用户体验。动画是不易发现的异步操作，我们经常会在播放动画后，执行某种操作。类似于上面的网络请求例子，当有多个动画执行，如何控制动画的执行顺序和回调的运行时机是动画中非常重要的部分。 我们以两种常见的动画场景举例： 多个动画顺序播放，播放完成执行回调 function main() { let players: Player[] = [p1, p2, p3, p4, p5]; playAnimations(players, () =&gt; { console.log('Animation over!'); }); } function playAnimations(players: Player[], callback: Function) { if (players.length &gt; 0) { player = players.shift(); playerMoveAnimation(player, playAnimations(players, callback)); } else { callback(); } } function playerMoveAnimation(player: Player, callback: Function) { player.playMoveAnimation(callback); } 在这种动画情况下，我们在上一次动画执行完的回调里执行下一次回调，举例的还是一样的动画，可以用递归的方式处理。如果每次动画都是不相同的，则很容易导致回调地狱。 多个动画同时播放，播放完成执行回调 function main() { let players: Player[] = [p1, p2, p3, p4, p5]; let callback = () =&gt; { console.log('Animation over!'); }; players.forEach((player, index) =&gt; { let func = index == (players.length - 1) ? callback : null; playerMoveAnimation(player, func); }); } function playerMoveAnimation(player: Player, callback?: Function) { ... } 上述代码在执行回调时，判断是不是最后一个动画，如果是最后一个动画，则把回调传入，否则传入空值。这种还是最简单的情况，我们假设每个动画的时间是一样的。但是如果每个动画的时长不同，如何在动画时长最长的动画播放完成之后执行回调，是需要花一番工夫的，我们需要获取到每次动画的动画时长，然后根据动画时长判断是否需要传入回调。 动画的 Promise 实现方式 针对于上面举例的动画案例。我们用 Promise 如何优雅的解决。 多个动画顺序播放，播放完成执行回调 function main() { let players: Player[] = [p1, p2, p3, p4, p5]; let promise = players.reduce((pre, cur) =&gt; pre.then(playerMoveAnimationAsync(cur)), Promise.resolve()); promise.then(_ =&gt; console.log('Animation over!')); } function playerMoveAnimationAsync(player: Player) { return new Promise(resolve =&gt; { player.playMoveAnimation(resolve); }); } 通过将每个动画转换成 Promise 的形式，然后利用 Promise 的 then 将每个动画 Promise 连接起来，Promise 会在执行完之后再执行 then 方法，这样就实现了动画播放，我们只需要监听最后的 Promise 的 then 方法，执行我们的回调，就实现了动画需求。 相较于普通的回调处理方式，Promise 的方案更为简洁，同时动画的调整也会变得更为便捷。 多个动画同时播放，播放完成执行回调 function main() { let players: Player[] = [p1, p2, p3, p4, p5]; let promises = players.map(player =&gt; playerMoveAnimationAsync(player)); Promise.resolve().then(_ =&gt; Promise.all(promises)).then(_ =&gt; console.log('Animation over!')); } function playerMoveAnimationAsync(player: Player) { ... } 这里通过 Promise.all 方法来处理动画 Promise 数组，Promise.all 这个方法会在所有的 Promise 执行完成，才会执行 then 方法。 这个方法完美契合我们同时执行动画的需求，而且不用担心每个动画的动画时长不一样，因为这个方法会等待所有 Promise 执行完成，所以会在动画时长最长的动画运行完再执行回调。 Promise 的注意点 上面的举例都只考虑了 Promise 正常执行的情况，如果 Promise 抛出 reject，如何应对是需要注意的点。如果在每个 Promise 的 then 方法单独处理 reject 回调，会显得很有点繁琐，也可能会出现很多重复代码。如果统一用 catch 处理，又会难以辨别 reject 是哪个 Promise 抛出的。 如果封装的 Promise 只给自己使用，我们可以了解 Promise 内部是如果处理 resolve 和 reject 的。但是封装的 Promise 要提供给他人使用，就需要统一 resolve 和 reject 的处理标准，并且一直遵守，当有统一的共识存在。如何应对 reject 以及针对不同的 reject 恢复程序状态，就会显得很轻松。 最后 在程序的世界里，是没有银弹可以解决一切问题，只有针对于特定需求的最佳解决方案。所以，多学习了解各种技术，是程序员进阶的必不可少的步骤。 ","link":"https://lzhenhong.github.io/post/promise-yu-dong-hua/"},{"title":"整洁的代码","content":"在说到写代码这件事之前，可以先来聊聊程序员这份职业。我不太清楚大家对于程序员这份职业的理解是什么，我简单说下我对程序员认知的变化吧，或者说我对职业的认知。 几年前大四要毕业的我磕磕碰碰找了份游戏开发的工作，初入职场的我对程序员这份工作感到很新奇，看似每天如饥似渴的学习着功能开发，做着每天安排的需求，好似每天都在进步。当时对程序员的认知就是每天写着代码，开发着需求，完成安排的工作就好了。久而久之，就会发现每天都在重复做的同样的事情，bug 层出不穷，技术也没有提升，一直都在原地踏步。渐渐的，失去了写代码的兴趣，也对程序员这个职业没有了激情。 不知道怎么的去年 3 月份突然开窍，写代码这件事是我们程序员的手艺啊，是我们赖以生存的工具，不好好琢磨提升这门手艺，注定会被淘汰。写代码这门手艺的门槛很低，因为代码是不会面向用户的，代码是在底层运行，用户面对的是界面操作，界面好不好看，功能好不好用，是用户关心的，至于代码写的好不好，大概只有程序员关心。因此，不管好代码、烂代码，只要在面对用户没有致命的 bug，也就不会有太大问题，导致很多项目的代码在中后期就没法维护了，或者维护起来很困难。 程序员写代码，就像木匠雕刻工艺品，厨师烹饪佳肴。不能因为代码藏的深，不直接面对用户，而忽略了这门手艺的修炼。不管在任何行业，做着什么样的工作，磨练手艺都是重要的。 闲扯了很多，还是继续我们的主题吧。 在作为程序员工作了五年之后，发现程序员的工作更多时间都是在阅读代码，而不是在写代码。不管是做需求，还是改 bug，或者是想优化结构，代码总是在被修改，修改代码之前就需要理解代码在做的事情，了解上下文。所以，利于阅读和理解的代码就是整洁的代码。 命名 命名这件事放到第一个说，因为它真的太重要了。程序员在写代码期间，每时每刻都在命名，类名、变量名、函数名、接口名等。 命名准确 好的命名有助于理解代码段正在做的事情。例如： int d = 5; 你可以一眼看出来这个变量代表的含义吗，我相信大部分程序员应该是不理解的。要理解这个变量的含义，就需要浏览代码上下文，理解代码段逻辑之后再去推断。 int dayPassedSinceSunday = 5; 这个变量名代表的含义我相信即使不是程序员也能看出来。阅读的人不需要了解上下文做了什么事情，只需要看到这个名称就可以理解。 少使用魔数 魔数指的是在代码中出现的整数字面量，没有任何含义，它就这样出现，触不及防。 for (let i = 0; i &lt; 7; ++i) { // do something with varible i } 上面代码中出现的数字 7，就是 magic number，它代表的含义不明，而且可能散落在代码各处，当要修改的时候，完全不知道各处的魔数是否代表同一含义。 const MAX_PLAYERS_IN_ROOM = 7; for (let i = 0; i &lt; MAX_PLAYERS_IN_ROOM; ++i) { // do something with varible i } 上面的数字字面量被常量取代了，数字 7 有了自己的含义。而且即使代码中多处使用了常量 MAX_PLAYERS_IN_ROOM，要修改的时候只需要修改常量定义这一处，不需要每一处去改动。 这里只是以整数举例，在代码中都不应该直接出现字面量，如字符串、整数、布尔值等等，要为它们赋予含义，统一使用，在以后的阅读和修改都会感受到好处。 注释 代码注释拿出来单独说，是因为每个程序员对写注释的态度都不一样，有些程序员不喜欢写注释，有些程序员注释比代码更详细。 首先，我们应该要明白几点： 注释不能优化代码，烂代码不会因为注释变成好代码。 注释可能告诉你错误的信息，只有代码才是最真实的，因为代码会有很多人去修改、去维护，但是不一定每个程序员都会去维护注释。久而久之，注释可能出现在其他位置，与最开始注释的代码相距甚远。还会出现需求逻辑已经被修改，但是注释描述的是之前的逻辑。 很多程序员喜欢注释代码，觉得可能会出现需求被改成之前的逻辑。但是现在有 Git、SVN 等版本控制工具，你删掉的代码在任何时候都可以被找回。别人看到注释掉的代码，认为这个代码可能还有其他用处，就导致注释的代码一直留着，无人问津。 注释跟命名也会有一定联系，好的命名就相当于注释。这种加注释描述的形式：int d = 5; // 距周日过去了多少天，不如准确的命名：int dayPassedSinceSunday = 5;。 应该加注释的地方是代码表现不出来的地方，代码只能解释“怎么做”，但为什么这么做代码是表现不出来的。一些啰嗦、冗余、抖机灵的注释不应该出现，它会分散读者的视线。 代码风格 每位程序员有各自写代码的习惯和风格，但是作为一个团队，代码的风格需要统一。如果在项目中出现多种风格的代码就像是你在语文书中看到数学书中的文字，你需要暂时停下来转化下思维，才能继续读下去。 在项目启动之前，团队成员需要一起制定项目的代码风格，输出成文档。不管你是否喜欢，既然大家达成共识，就要遵守。统一编写代码的风格，也是利于代码阅读的有效方式。 设计模式 设计模式是从实际项目中总结出来的，是某些特定问题下的最佳实践。在合适的时机使用设计模式，可以保证代码的重用性、可扩展性。 设计模式是程序世界中的被广泛认可的，标准的设计模式实现在其他也了解设计模式的程序员看起来会非常亲切和熟悉，自然也就容易理解和阅读。 作为程序员，要熟悉、了解常用的设计模式，基础的工厂模式、单例模式、组合模式等等。更详细可看：设计模式。 编程思想 现在编程世界的语言太多了，C / C# / C++ / Objective-C / Swift / Java / TypeScript / Python / Rust 等等，当熟练掌握了一门编程语言，会发现转向其他语言时，刚写出来的代码都是带着之前编程语言的味道。因为编程语言在设计时是带着设计者的思想，设计者会把自己的编程思想灌注到编程语言，这样就导致编程语言的最佳实践会有很大差异。例如：C 语言是面向过程的语言，C# 是面向对象的语言，这样的差异就会导致在解决同样的问题解决思路完全不一样。 当时在 Apple 在推出 Swift 之后，刚写 Swift 代码挥发现怎么写怎么别扭，写出来的代码带着浓浓的 OC 味，也很不理解为什么 Swift 会给枚举增加这么多功能，枚举可以定义方法，可以携带关联值。但是在熟悉了语言后，就会发现 Swift 针对于某些问题有完全不同的实现方式，相较于 OC 的实现更为优雅、整洁。而且 Swift 在提升了扩展的等级后，发展出了 POP（面向协议编程），跟面向过程编程和面向对象编程完全不同的思想。 我们学习一门编程语言，不应该只关注于语言的语法，更应该关注设计者表达的思想。了解设计者的思想之后，就能写出更合理、优雅的代码。 最后 试着回想一下，你是否有过看着过去写的代码觉得很羞耻的感觉，觉得代码写的真垃圾。其实不用太在意，几乎没有人可以在一开始就把代码写的整洁，利于阅读。即使做了提前设计，中途也会因为需求变化，或者其他原因，导致最终实现与初期的设计相距甚远。代码是需要修改和维护的，初期代码实现也繁杂，而且也不能考虑到所有情况，不能一直保持代码的整洁，不过我们需要时刻提醒自己注意代码的整洁，尽可能保证代码优雅。 就像代码一样，人站在今天审视着过去的自己，很容易对以前产生种种不满，会做出各种假设、如果，而忽视了今天的自己。渐渐的，今天的自己变成昨天的自己，昨天的自己依然做着假设，时间就这样悄然而逝。 过去已然，未来不明，现在可改。 也许有一天，你不再是程序员，进入了其他的行业，做着不同的工作。同样，你也不该停下学习的脚步，不管在哪一行，做着什么样的工作，技巧需要练习，技艺需要精进。 ","link":"https://lzhenhong.github.io/post/zheng-ji-de-dai-ma/"},{"title":"集合函数式编程","content":"相信大多数程序员接触到的第一门编程语言都是 C 语言，我们的编程思维基本上都是 C 语言帮助我们塑造的，这种编程思想会贯彻我们整个职业生涯。C 语言是一门面向过程的语言，表达力强、非常直观，是初学编程接受程度较高的语言。但是随着程序应用越来越广泛，面向过程的编程思想对现实世界的抽象稍显不足。 一般接下来接触的就是面向对象的编程语言，一般是 Java 或者 C++，现在流行的编程语言几乎都是面向对象，面向对象的编程思想足够我们应付几乎所有的问题，即使你不了解文章要说的函数式编程也没有任何问题，也不会对我们在日常编程中解决问题有什么影响。但是理解函数式编程会在解决某些问题上显得更优雅，函数式编程和面向对象编程并不冲突，没有孰优孰劣。相反，这两种编程思想是相辅相成的，现在很多语言，例如：Java、C# 等，随着编程思想的发展，在面向对象的基础上也开始支持函数式编程，为我们解决问题提供多种方案，像 Swift 这种新兴语言从一开始就是支持面向对象和函数式编程的。所以，了解函数式编程是很有必要的。 数组 for 循环遍历 数组是 C 语言中常见的数据结构，也是我们在编程过程中常接触的，对于数组的遍历，C 语言中的方式就是使用 for 循环或者 while 循环。 #include &lt;stdio.h&gt; int main() { int n[10]; int i, j; for (i = 0; i &lt; 10; ++i) { n[i] = i + 100; } for (j = 0; j &lt; 10; ++j) { printf(&quot;第[%d]个 = %d\\n&quot;, j, n[j]); } return 0; } 尽管后续的一些语言中有 for-in 或者 for-of 的遍历方式，但跟 C 语言的 for 循环遍历也是差不多的，只是省去了我们从数组中取出元素的步骤，但是这样我们需要自己维护遍历索引。 using System; class TestArray { static void Main(string[] args) { int[] n = new int[10]; for (int i = 0; i &lt; 10; ++i) { n[i] = i + 100; } foreach (int j in n) { int i = j - 100; Console.WriteLine(&quot;第[{0}]个 = {1}&quot;, i, j); } Console.ReadKey(); } } 这种 C 语言风格的数组遍历方式是我们操作数组元素的基础，如果我们需要对数组中的某些元素进行操作，我们也会遍历数组中所有的元素，在进行操作之前先判断是否符合要求，不符合要求则用 continue 跳过。考虑数组的操作一直都是停留在数组元素上，没有从数组的整体来思考。函数式编程会从更高的层次来考虑，把数组当作整体，我们对数组元素的判断其实就是对数组进行过滤，然后再对过滤后的数组进行操作，函数式编程将这些数组常用的操作封装起来，让我们从另一种角度操作集合。 函数式操作集合 在上文有提到过，函数式操作集合是从整体上考虑的，这种方式不会聚焦于集合中的元素。它将我们对集合的常用操作抽象出来，例如：过滤、遍历、转换等，分别对应的函数就是 filter/forEach/map，这里使用的是常用的函数名，一些语言有相同作用的函数，但是名称可能会不一样。 这里举一个例子，将数组中为双数的数字翻倍之后打印出来。 C 语言风格的遍历 let nums: Array&lt;number&gt; = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; nums.length; ++i) { let num = nums[i]; if (num % 2 != 0) { continue; } num *= 2; console.log(`number: ${num}`); } 上面的代码是很典型的 C 语言风格的遍历，可以看到我们是针对于单个元素，在遍历中取出单个元素，然后进行需求中的操作。这种方式很符合我们的直觉，在很长一段时间里，我都是以这种方式来处理集合的，集合拿到手上不管三七二十一，先执行遍历，随后在对单个元素执行我们想要的操作。 函数式风格 let nums: Array&lt;number&gt; = [1, 2, 3, 4, 5]; nums.filter(num =&gt; num % 2 == 0) .map(num =&gt; num * 2) .forEach(num =&gt; console.log(`number: ${num}`)); 函数式的风格相较于 C 语言的风格，一眼看上去没有那么好理解，其实是非常简单的。在 C 语言风格执行的 continue 操作，就相当于函数式编程中的过滤，对应到例子上就是过滤出双数，然后执行转换操作，对应到例子上就是将双数翻倍，然后遍历翻倍后的计算结果打印出来。 当熟悉了集合常用的操作函数，会发现这种方式对集合问题的抽象更为合理，并且更为简洁，尽管 C 语言风格更为直观，但是程序员就应该用更合理、更优雅的方式来解决问题。以 TypeScript 语言为例，TS 还为集合提供了其他有用的操作，例如 reduce/find/findIndex/some/every。 我们把上面的例子扩展一下，将数组中为双数的数字翻倍之后相加，打印相加之后的数值。 C 语言风格 let nums: Array&lt;number&gt; = [1, 2, 3, 4, 5]; let sum = 0; for (let i = 0; i &lt; nums.length; ++i) { let num = nums[i]; if (num % 2 != 0) { continue; } sum += num * 2; } console.log(`number: ${sum}`); 在 C 语言的风格里我们需要额外定义一个变量 sum 来保存上次遍历相加后的数值。 函数式风格 let nums: Array&lt;number&gt; = [1, 2, 3, 4, 5]; let sum = nums.filter(num =&gt; num % 2 == 0) .map(num =&gt; num * 2) .reduce((pre, cur) =&gt; pre + cur); console.log(`number: ${sum}`); 函数式的方式把每一步区分的非常明显，我们可以任意增加和删减其中一步。得益于 TS 箭头函数的支持，相较于 C 语言风格的实现更为整洁。 总结 当然函数式编程能做的事情非常多，这里介绍的只是集合函数式编程的基础，语言给我们提供了好用的工具，如何组合这些工具去解决问题，是我们在实际编程中要去思考的。当然，函数式编程不是万能的，它只是针对于某些问题有更好的解决方式。 也许有人会说不用函数式也能解决问题，函数式编程没啥用。但是作为程序员的我们，学习如何把需求更优雅的解决，不是应该的吗，毕竟需求总是在变，代码总会被修改。 写好代码应该是每一个程序员的追求。正如诗人对写出好诗的追求，画家对画出好画的追求。 ","link":"https://lzhenhong.github.io/post/han-shu-shi-bian-cheng-xiao-jie/"},{"title":"Unity 热更 ILRuntime 基本原理","content":" CIL: Common Intermediate Language，通用中间语言 CLI: Common Language Infrastructure，通用语言基础结构 JIT: Just-in-Time compilation，即时编译 AOT: Ahead-of-Time，提前编译或静态编译 对 Unity 有一定的了解应该都知道 Unity 本身是不支持热更新的，但是在各种需求的驱使下，想要完全不用热更新几乎是不可能的，所以就诞生了很多热更新方案。有 tolua、xlua 这些成熟的 lua 解决方案，也有就是完全用 C# 实现的 ILRuntime 方案，因为热更新的代码也是用 C# 实现，没有 lua 的学习成本，现在 ILRuntime 的热更新方案越来越流行。 我们今天就着重介绍一下 ILRuntime 以及它的基本原理。 为何 Unity 不支持热更新 要解释为何 Unity 不支持热更新就要从 Unity 是如何实现跨平台说起。Unity 会先将代码编译成叫做 CIL 的代码指令集，CIL 可以在任何支持 CLI 的环境中运行，Unity 最开始使用的 Mono 运行时来支持 CIL 的运行，现在也可以使用 Unity 自身实现的 IL2CPP 来支持 CIL 的运行，运行时可以将 CIL 指令集转换成平台的本地指令， 所以我们可以在 Unity 用 C# 实现一套代码然后在多平台上运行。 通过上面的图我们看到整体的流程，首先我们通过 C# 代码编写游戏逻辑，Unity 打包会将 C# 编译成 CIL，然后通过 Mono 运行时运行在原生平台上，这样就实现了游戏的跨平台。 现在我们集中在 Mono 运行时上，我们需要了解一下 Mono 是如何将 CIL 编译成原生平台的机器码，Mono 提供了两种编译方式：JIT 和 AOT，JIT 会在运行才进行编译，AOT 会提前将代码编译好随后直接运行。既然 Mono 提供了 JIT，从技术上的角度来说，是可以进行热更新，为什么 Unity 不支持呢？原因就是 iOS、PS、Xbox 等平台是不允许 JIT 的，Unity 要支持这些平台，即使其他平台可以实现热更新，但是 Unity 官方也没有提供热更新方案。 程序域 AppDomain Unity 在运行期间会默认构建一个程序域 AppDomain，程序域中是可以加载多个程序集 Assembly。例如：Unity 的程序域中会存在 System.dll、UnityEngine.UI.dll 等。 Unity 会将未放在 StreamingAssets 路径下的程序集都加载到默认的程序域中，如果将热更新的 DLL 文件放在其他目录下，随后再去加载热更新 DLL，这种方式热更新的 DLL 不会生效，Unity 使用的还是之前的热更新 DLL 文件。如果不考虑不支持 JIT 的平台，其实也可以用利用 C# 动态加载 DLL 来实现热更新。如下所示： string dllPath = &quot;{DLL_Path}&quot;; var dllUri = new Uri(dllPath); UnityWebRequest webRequest = UnityWebRequest.Get(dllUri); yield return webRequest.SendWebRequest(); if (webRequest.isNetworkError || webRequest.isHttpError) { Debug.LogError($&quot;Load Hotfix DLL error at path: {dllPath}&quot;); yield return null; } byte[] mDllBytes = webRequest.downloadHandler.data; webRequest.Dispose(); try { Assembly assembly = Assembly.Load(mDllBytes); var types = assembly.GetTypes(); for (var innerType in types) { if (innerType.Name == &quot;Class_Name&quot;) { var instance = Activator.CreateInstance(innerType); MethodInfo method = innerType.GetMethod(&quot;Method_Name&quot;); if (method != null) { var returnValue = method.Invoke(instance, null); Debug.Log(&quot;Return value: &quot; + returnValue); } } } } catch (Exception exception) { Debug.LogError(exception.Message); } ILRuntime ILRuntime 的使用是需要区分两个 VS 工程，一个是 Unity 生成的主工程，另一个就是生成 DLL 文件的热更工程，ILRuntime 通过解析 DLL 文件实现热更新。 根据 ILRuntime 官网上的介绍：&quot;ILRuntime 借助 Mono.Cecil 库来读取 DLL 的 PE 信息，以及当中类型的所有信息，最终得到方法的 IL 汇编码，然后通过内置的 IL 解译执行虚拟机来执行 DLL 中的代码。&quot; DLL 的内容就是 IL 指令，CIL 类似一个面向对象的组合语言，并且它是完全基于堆栈的，它运行在虚拟机上。从 ILRuntime 官网上的定义可知，ILRuntime 实现了 IL 解释执行虚拟机和自己的 IL 托管栈来模拟代码的执行，在 ILRuntime 解释执行期间，所有的对象都是用 StackObject 表示的，没有新类型的生成，所以不存在运行时编译的情况，由此可以实现热更新的动态加载。 ILRuntime 使用 简单使用 ILRuntime.Runtime.Enviorment.AppDomain appdomain; void Start() { StartCoroutine(LoadILRuntime()); } IEnumerator LoadILRuntime() { appdomain = new ILRuntime.Runtime.Enviorment.AppDomain(); var dllUri = new Uri(dllPath); UnityWebRequest webRequest = UnityWebRequest.Get(dllUri); yield return webRequest.SendWebRequest(); if (webRequest.isNetworkError || webRequest.isHttpError) { Debug.LogError($&quot;Load Hotfix DLL error at path: {dllPath}&quot;); yield return null; } byte[] dll = webRequest.downloadHandler.data; webRequest.Dispose(); var pdbUri = new Uri(pdbPath); webRequest = UnityWebRequest.Get(pdbUri); yield return webRequest.SendWebRequest(); if (webRequest.isNetworkError || webRequest.isHttpError) { Debug.Log($&quot;Load Hotfix PDB error at path: {pdbPath}&quot;); yield return null; } byte[] pdb = webRequest.downloadHandler.data; webRequest.Dispose(); System.IO.MemoryStream fs = new MemoryStream(dll); System.IO.MemoryStream p = new MemoryStream(pdb); appdomain.LoadAssembly(fs, p, new Mono.Cecil.Pdb.PdbReaderProvider()); OnILRuntimeInitialized(); } void OnILRuntimeInitialized() { appdomain.Invoke(&quot;Hotfix.Game&quot;, &quot;Initialize&quot;, null, null); } 要使用 ILRuntime 首先要创建一个 ILRuntime.Runtime.Enviorment.AppDomain 热更新域，通过这个热更新域加载热更新 DLL，随用调用热更新 DLL 的入口。在游戏运行期间，只保留一个热更新域，与热更新 DLL 的交互都需要使用这个 AppDomain。 CLR 绑定 默认情况下，热更新 DLL 中访问主工程和 Unity 的接口，是通过反射的方式来实现的。通过反射的方式调用接口的效率会比直接调用低很多，同时调用期间会产生很多临时变量，造成额外的 GC Alloc，会引起性能问题。 因为上述原因，ILRuntime 使用 CLR 绑定机制来尽可能规避上述问题。CLR 绑定是借助了 ILRuntime 的 CLR 重定向机制来实现，CLR 重定向的实现原理是 ILRuntime 的 IL 解释器发现需要调用某个方法时，可以将这个方法的调用指定到另一个方法的实现，由此实现方法的挟持。 CLR 重定向方法的编写需要对 ILRuntime 的底层非常了解，并且工作量巨大，因为热更新 DLL 不可避免调用主工程和 Unity 的接口，这样就需要实现很多重定向的方法。幸运的是 ILRuntime 提供了工具来自动生成 CLR 绑定代码。 [MenuItem(&quot;ILRuntime/Generate CLR Binding Code by Analysis&quot;)] static void GenerateCLRBindingByAnalysis() { // 用新的分析热更 dll 调用引用来生成绑定代码 ILRuntime.Runtime.Enviorment.AppDomain domain = new ILRuntime.Runtime.Enviorment.AppDomain(); using (System.IO.FileStream fs = new System.IO.FileStream(&quot;{Hotfix_dll_path}&quot;, System.IO.FileMode.Open, System.IO.FileAccess.Read)) { domain.LoadAssembly(fs); // Crossbind Adapter is needed to generate the correct binding code InitILRuntime(domain); ILRuntime.Runtime.CLRBinding.BindingCodeGenerator.GenerateBindingCode(domain, &quot;Assets/ILRuntime/Generated&quot;); } AssetDatabase.Refresh(); } static void InitILRuntime(ILRuntime.Runtime.Enviorment.AppDomain domain) { // 这里需要注册所有热更DLL中用到的跨域继承Adapter，否则无法正确抓取引用 domain.RegisterCrossBindingAdaptor(new MonoBehaviourAdapter()); domain.RegisterCrossBindingAdaptor(new CoroutineAdapter()); domain.RegisterCrossBindingAdaptor(new TestClassBaseAdapter()); domain.RegisterValueTypeBinder(typeof(Vector3), new Vector3Binder()); } 在 CLR 绑定代码生成之后，需要将这些绑定代码注册到 AppDomain 中才能使 CLR 绑定生效，但是一定要记得将 CLR 绑定的注册写在 CLR 重定向的注册后面，因为同一个方法只能被重定向一次，只有先注册的那个才能生效。 其他 关于热更新 DLL 与主工程的交互还有委托、跨域继承、反射和 CLR 重定向。更详细的内容可以访问 ILRuntime 的官方文档。 ILRuntime 注意点 目前 ILRuntime 在处理逻辑数学计算的时候，效率低于 Lua，本质上是因为一个是 stack 虚拟机，一个是 register 虚拟机。所以尽量把数学计算多的部分转移到框架层。Hotfix 中不要写大量复杂的计算，特别是在 Update 之类的方法中。 Xcode 调试会经常出现爆栈，因为 iPhone 的线程栈空间很小，稍微深一点的调用就会出现爆栈，可以将 Xcode 工程调成 Release 模式。 热更代码需要尽量减少 foreach 的使用，由于原理限制，在热更中使用 foreach 无法避免产生 GC Alloc，请使用支持 for 循环的数据结构，或者用 List 等支持 for 遍历的结构辅助 Dictionary 等无法 for 遍历的结构。 关闭 Development Build 选项来发布 Unity 项目。在 Editor 中或者开启 Development Build 选项发布会开启 ILRuntime 的 Debug 框架，以提供调用堆栈行号以及调试服务，这些都会额外耗用不少性能，因此正式发布的时候可以不加载 pdb 文件，以节省更多内存。 相关链接 ILRuntime 官方文档 Unity3D 为何能跨平台？聊聊 CIL (MSIL) 谁偷了我的热更新？Mono，JIT，iOS Unity ILRuntime 详解 使用 ILRuntime 遇到的一些问题 Unity DLL 实现热更新 Unity 将来时：IL2CPP 是什么？ ","link":"https://lzhenhong.github.io/post/unity-re-geng-ilruntime-ji-ben-yuan-li/"},{"title":"iOS 审核遇到的问题","content":"最近游戏上线了 iOS 版本，期间来来回回提审了 2、3 次，最终没有经历太多波折顺利上线，写下这篇文章记录下审核期间遇到的问题，方便以后查看和提前避免一些问题。 机审 ITMS-90683: Missing Purpose String in Info.plist - 这个问题是游戏使用的一个选图片的第三方库用到了 NSPhotoLibraryUsageDescription 和 NSLocationWhenInUseUsageDescription 权限，但是在 Info.plist 中没有声明，造成机审没过。 TMS-90809: Deprecated API Usage - 这个是因为 Apple 的政策，新提交审核的应用不能再使用 UIWebView，必须换成 WKWebView，这个对照着 Cocos 官方库的修改，将 Cocos 引擎的 UIWebView 升级到 WKWebView。 ITMS-90191: Missing beta entitlement - 这个问题是因为没有使用发布的证书打包，而是使用了 ad-hoc 证书，导致上传失败，使用发布证书打包就解决了问题。 人审 Guideline 4.8 - Design - Sign in with Apple - 这个也是 Apple 的政策，我们游戏接入了 Facebook 登录，Apple 的政策是如果你的游戏或者 App 有第三方的登录渠道，就必须也要接入 Sign in with Apple。解决方案：iOS 13 接入 AuthenticationServices，iOS 13 之前的设备不管。 Guideline 2.3.6 - Performance - Accurate Metadata - 这个是因为游戏填写的年龄评级不对。解决方案：修改年龄评级符合政策规范。 Guideline 2.1 - Information Needed - 这个是游戏提交审核的游戏内购买商品没有在游戏中体现，导致不能购买测试而被拒。解决方案：写测试代码，将所有的游戏内商品放在明显的位置，供 Apple 审核。 Guideline 2.1 - Performance - App Completeness - 这个刚好和上一点相反，这个是在游戏内出现的购买商品没有在 App Store Connect 后台提交审核，导致被拒。解决方案：将所有的游戏内购买商品都提交审核。 奇葩的事 我们在修改了所有问题之后通过了 Apple 的审核，因为之前审核的包有测试代码，不能直接发布，随后我们就修改了最新的 iOS 包，然后再次提审准备发布我们的正式包，但是这个包的审核发生了一些奇怪的事情。 可以看到我们在 5.22 提交了我们新的版本，Apple 随后就开始审核，在 5.23 告知我们被拒绝了，但是拒绝邮件并不像之前那样明确指出问题在哪，而是给出了下面图的理由。 这个邮件说需要更多时间来审核，但是又告知我们被拒，我们之后也重复申诉了，但是 Apple 回的邮件内容与上图都是相似的。没办法我们也只能等，等了一周的时间，在第一张图可以看到，Apple 在 5.30 又开始审核我们的游戏，并且在 5.31 告知我们审核通过。 这个事情就很奇葩吧，但是也没办法，谁让咱们要靠着 Apple 吃饭呢 😔。 Apple 每次发版本都需要重新审核的，在后续的审核中碰到问题，也会更新上来。 ","link":"https://lzhenhong.github.io/post/ios-shen-he-yu-dao-de-wen-ti/"},{"title":"热更新实现流程","content":"最近游戏的热更新出了一些问题，导致崩溃率有点上升，并且热更新有些文件没有生效。游戏中用的热更新模块是 Cocos 引擎提供的，就花了点时间去翻了 Cocos 的源码文件 AssetsManagerEx.cpp，了解了 Cocos 引擎处理热更新的流程以及问题，也借此机会思考下热更新的处理逻辑。 Cocos 热更新的 Manifest 文件 在 Cocos 的热更新中有一个重要的 Manifest 文件，检查热更新和下载热更新相关的信息都包含在这个文件中，App 包内有一个本地的 Local Manifest，同时里面有个 &quot;remoteManifestUrl&quot; 字段指向远程的 Remote Manifest，这个 Remote Manifest 当有热更新资源时会更新，Cocos 检查有新的热更新就会下载这个 Remote Manifest，然后判断是否新的热更新，有的话则下载新的热更新文件。随后将 Remote Manifest 缓存成 Cache Manifest。 Local Manifest { &quot;packageUrl&quot;: &quot;http://xxx.com/&quot;, &quot;remoteManifestUrl&quot;: &quot;http://xxx.com/AppUpdate/project?version=1.0.0&quot;, &quot;remoteVersionUrl&quot;: &quot;http://xxx.com/AppUpdate/version?version=1.0.0&quot;, &quot;version&quot;: &quot;1.0.0.0&quot;, &quot;engineVersion&quot;: &quot;Cocos2d-JS v3.16&quot; } 这个一般是 App 包内的 Manifest 文件，这里主要申明的是 Version，热更新资源 CDN 地址， Remote Manifest 地址和 Version Url。 Remote Manifest { &quot;packageUrl&quot;: &quot;http://xxx.com/cdn&quot;, &quot;remoteManifestUrl&quot;: &quot;http://xxx.com/AppUpdate/project?version=1.0.0&quot;, &quot;remoteVersionUrl&quot;: &quot;http://xxx.com/AppUpdate/version?version=1.0.0&quot;, &quot;version&quot;: &quot;1.0.0.2&quot;, &quot;engineVersion&quot;: &quot;Cocos2d-JS v3.16&quot;, &quot;groupVersions&quot;: { &quot;1&quot;: &quot;1.0.0.1&quot;, &quot;2&quot;: &quot;1.0.0.2&quot; }, &quot;assets&quot;: { &quot;src_1.0.0.1_f1b1d1040801913b99fd15ed208ed830.zip&quot;: { &quot;md5&quot;: &quot;f1b1d1040801913b99fd15ed208ed830&quot;, &quot;compressed&quot;: true, &quot;group&quot;: &quot;1&quot; }, &quot;src_1.0.0.2_e3d58ae365a5a1c2fe2220f3c5968c8e.zip&quot;: { &quot;md5&quot;: &quot;e3d58ae365a5a1c2fe2220f3c5968c8e&quot;, &quot;compressed&quot;: true, &quot;group&quot;: &quot;2&quot; } }, &quot;searchPaths&quot;: [] } 这个是在 1.0.0 版本发过两次热更的 Remote Manifest 文件，主要的是 version 字段、groupVersions 字段和 assets 字段，version 字段表示当前的热更新版本，这个是判断是否有新的热更资源最重要的字段，assets 对应的是热更新的 CDN 资源，下载热更热更新资源要使用到 packageUrl 和 assets 字段的组合。 Cocos 热更新步骤 加载 App 包内的 Local Manifest，Cocos 会使用这个文件来判断是否有新的热更新资源。在加载 Local Manifest 的同时会尝试去加载 Cache Manifest，如果 Cache Manifest 存在，则会先判断这两个 Manifest 的 Version 字段。如果本地的 Manifest 文件比缓存的 Manifest 的文件 Version 要大或者等于，则删除热更新目录，Cocos 认为 App 的代码比热更新的代码要更新。如果本地的 Manifest 文件比缓存的 Manifest 文件的 Version 要小，则使用 Cache Manifest 去跟 Remote Manifest 做对比。如果没有 Cache Manifest，就继续用 Local Manifest 做对比。 调用 jsb.AssetsManager 的 checkUpdate 方法开始检查是否有新的热更新资源。在检查之前会下载一个 Version Manifest 文件，这个文件主要的字段就是 Version 字段，Cocos 通过这个字段来判断是否有新的热更新资源，如果本地 Manifest 的 Version 比这个 Version Manifest 的 Version 要大或者等于的话，就直接删除临时热更新目录，并直接完成热更新流程。如果本地 Manifest 的 Version 比 Version Manifest 的 Version 要小，就开始下载 Remote Manifest。 下载好 Remote Manifest 之后，开始比较 Remote Manifest 和 Local Manifest 的 Version 字段，Remote Manifest 的 Version 比 Local Manifest 的小或者等于，就直接删除临时热更新目前，完成热更新流程。如果 Remote Manifest 比 Local Manifest 要大，则开始现在热更新资源包。 开始下载热更新的时，Cocos 会检查是否有未完成的热更新包，同时也会检查 MD5 值有变化的热更新包，生成一个下载队列。AssetsManager 中有一个 _maxConcurrentTask 属性来控制同时下载热更新包的数量。 下载好一个热更新包之后，就开始解压 Zip 包，等所有的热更新 Zip 包下载完成后，就将热更新资源从临时路径拷贝到指定的缓存热更新路径。随后通知代理热更新下载完毕。 Cocos 热更新问题 按照理想的情况，Cocos 的热更新是可以正常运行。但是在游戏上线一段时间后，我们发现 Cocos 的热更新是存在问题的。如果一次性下载多个热更新包，Cocos 不能保证热更新包下载完成的先后顺序，这个就导致了如果两个热更新包包含同一个代码文件，但是新的代码文件比旧的代码文件先下载好，就会导致旧的代码文件将新的代码文件覆盖。这里的解决办法就是将 _maxConcurrentTask 属性设为 1，让 Cocos 每次只下载一个热更新包，这样来保证热更新包下载的顺序。Cocos 热更新组件还是有个问题，就是热更新组件维护热更新包下载顺序用的 unordered_map，并且插入热更新包资源用的是 push_back，这个就导致虽然热更新包是串行下载的，但是下载的顺序不能保证，解决方案是将维护下载顺序队列的维护成 map。 热更新的优化 从 Cocos 的热更新系统，我自己也受了一点启发。虽然 Cocos 的热更新系统基本功能都有，但是还是存在一些问题，热更新是没办法回滚的，重发的热更也需要有新热更触发下载才会触发 MD5 值变化的下载，同时下载多个热更新包如何保证顺序，热更新流程的优化可以从这几方面入手。 ","link":"https://lzhenhong.github.io/post/re-geng-xin-shi-xian-liu-cheng/"},{"title":"从零开始做游戏","content":"最近一年多的时间几乎都花在一款游戏上面，这款是自己一个人从零到一做起来的，现在已经完成的差不多了，最近准备正式上线，上线之后就会面临很多玩家，对游戏和自己都是很大的挑战。如何去处理好玩家反馈的问题，如何去更好的避免玩家遇到问题等等，这些都是后续需要提升的地方。先不说远了，在游戏正式上线之前就遇到很多问题，在这里记录一下完成这款游戏遇到的问题。 初印象 因为在做这款游戏之前，我自己就参与过两款游戏的开发，因为在之前的游戏开发过程没有遇到过特别难解决的问题，并且在出现的时候也有人可以求助，就导致自己盲目自信，认为自己从零做一款游戏应该问题不大。 随后就与其他人一拍即合，自己做一款游戏，在定下来项目的方向之后，就创建好游戏的 git 仓库，不久就提交项目的 Init commit。完全没有做提前的调研，也没有提前研究游戏的技术难点。直接就开始对动手做项目，这也为后面埋下了很大的坑，导致后续花了很多时间去填补这些坑。 过程的困难 开发引擎的选择 因为之前接触的游戏引擎比较多的就是 Cocos-JS，所以这款游戏也就选用了这个引擎来做开发。Cocos-JS 引擎的特点就是上手容易，但是可能会遇到比较多的坑，这些坑掉进去了就很难爬出来。在开发过程中碰到印象比较深的问题有四个： cc.eventManager 有个问题，就是有多个监听者的时候，接收的事件参数会有问题，查了很久也没有找到具体问题在哪，最后没办法，因为项目开始还不久，直接就把引擎升级到 3.16 版本来解决。至于升级 Cocos 引擎也是个巨坑。 cc.TableView 删除 cc.TableViewCell 会导致 cell 上添加的 button 失去点击相响应，这个问题最开始我一直以为是我们自己代码有问题，也花费了不少时间，最后查到是引擎的 bug，在 remove cell 的时候 cleanup 了，但是 cell 是复用的，就导致这个被删掉的 cell 复用时不响应事件点击。更详细戳👈 这个算是比较小众的问题，因为游戏的语言是泰语的，使用 Cocos 引擎会导致一些泰语字上面被截断，如下图所示： 这个问题是因为 Cocos 引擎在 Android 层对文本尺寸进行计算的时候，高度没有算对，引擎在渲染文本的时候高度不够，导致截断。最后查到的问题是 Cocos2dxBitmap.java 中使用 StaticLayout 计算文本尺寸时有个参数 includepad 设置成了 false，导致 Android 计算时出现了文本截断，将参数改成 true 解决了问题。 Cocos 热更新组件也是存在很多问题的，Cocos 的热更新组件支持同时下载多个热更新包，但是又没办法保证热更新下载解压的顺序，如果你在两个热更新包都包含同一个代码文件，就有可能造成新的热更新的代码文件被老的热更新包的代码文件覆盖。这个问题最开始的解决方案是限制热更新组件的下载，让热更新包串行下载 this._assetsMgr.setMaxConcurrentTask(1);。但是热更新组件还是有个问题，就是热更新组件维护热更新包下载顺序用的 unordered_map，并且插入热更新包资源用的是 push_back，这个就导致虽然热更新包是串行下载的，但是下载的顺序不能保证。解决方案是将维护下载顺序队列的维护成 map。 这些是在开发中遇到的印象比较深的问题，还有比较多大大小小的问题。开发中不是怕遇到问题，而是遇到问题之后找不到解决办法，Cocos 开发中遇到的问题有些很难找到解决办法，一方面可能是没有其他人讨论资料不好找，另一方面是有人讨论但是没有最终的解决方案，这些就是比较坑的地方。还有一点就是 Cocos 的引擎升级，基本上在开发初期定下来了引擎版本，后面基本上就没有升级的可能，这也就意味着引擎后续的 bug 修复，性能优化等等，这些都是享受不到。最最坑的地方就是，Cocos 引擎团队放弃了 Cocos 引擎的维护，将重点转到 Cocos Creator，并且在 4.0 版本移除了 JavaScript 的支持，这就意味着，项目中使用的 Cocos-JS 引擎出现问题，后续很难得到引擎团队的解决。 开发中遇到的问题 大量的冗余代码。这个问题是目前项目中比较严重的问题，因为前期项目时间紧张，就大量使用 ⌘+C 和 ⌘+V，最后造成很多重复的代码，只要代码出现问题或者需求出现变动，要改的地方就很多，也容易漏掉，这样也造成了很多 bug。这个问题的原因是前期搭建项目框架时，缺少基础框架的搭建，在有相同功能的代码时，要多使用继承和封装，尽量避免复制粘贴代码。前期需要对项目的基础架构进行封装，确定项目的大概结构，对常用的基础控件进行封装，一方面是保证项目中使用的统一性，另一方面对方便后期对控件进行统一修改。不要一上来就对着业务撸代码，这样会给后期代码维护和扩展造成很多麻烦和难以填补的坑。 资源管理混乱。这个也是项目做到中后期遇到的比较大的问题，在游戏初期，游戏的玩法少，活动少，所以资源就不多，前期就忽略了资源管理规范的重要性，在游戏开发的中后期需要对整体的资源进行梳理和优化，在后期资源很多的情况也是一件很麻烦的事情。所以在前期定好资源管理的规范和资源加载的处理方式，会对后期的开发有很大的帮助，也对内存占用优化有很大的帮助。 内存峰值优化。其实对于我们这种体量的游戏，几乎可以忽略这一块。在游戏上线之前都没有重视这一块，但是上线之后崩溃率很高，最开始一直以为是代码逻辑的问题，没有往内存占用这一块考虑。但是最后优化了内存占用之后，崩溃率就稳定在比较合理的水平。这个是因为游戏发行在泰国，泰国玩家的手机机型普遍不高端，所以手机内存少，就导致游戏在运行期间容易发生崩溃。但是游戏如果发行在国内，这种情况会好很多。所以内存占用要提前考虑好策略，在编写代码的同时也要兼顾到内存占用的优化。 公测中遇到的问题 玩家反馈卡。游戏在上线测试之后，总是有玩家反馈网络卡顿。这个点我们花了很多时间去定位问题，然后去修复，都收效甚微，最终发现问题是因为前端在网络波动的情况下检测弱网和网络重连处理很慢，就网络波动的时候一直出现 loading，也不会触发重连，或者弱网出现重连的时间很久。就导致玩家的感受是游戏很卡，但是玩家反馈的很卡，其实有很多方面，游戏性能问题导致游戏卡顿，弱网情况下网络层出现问题导致玩家玩的时候很卡。所以在解决问题时，要先确定玩家具体的问题，再去检查问题，修复问题。前端发现问题之后，就很好修复，减少心跳包的间隔，建立 WebSocket 连接的检测等待时间缩短，压后台之后回到前台的策略优化。最后基本上解决了弱网情况下的游戏体验问题。 游戏崩溃率高。在游戏初期上线的时候，bugly 统计的崩溃率很高，这个有明确 log 上报，所以很好解决。但是后面玩家多了之后，崩溃率还是比较高，这个问题也是花了很多时间，从各个角度都考虑去解决，但是收效也是很小，最后还是内存占用的问题，因为泰国手机机型的特点，需要去优化内存占用。优化内存占用的时候也做了很多，动态加载图片资源，释放音频资源，最后都是没有把内存占用减下来。最后原因是 JS 引擎自动回收太慢的问题，导致游戏在运行期间不停生成中间对象，最后内存占用越来越高，泰国手机机型内存小，就很容易导致闪退。最后的解决方案就是 cc.sys.garbageCollect() 强制 JS 引擎回收内存，就能导致内存占用的峰值降下去，随后崩溃率就下降了很多。 游戏开发的基本步骤 游戏引擎的调研，这个是非常重要的，因为这个关系着后面游戏的性能，引擎 bug 的修复，以及开发中遇到问题的解决效率。 确定游戏的设计分辨率，一开始就需要确定下来，与美术约定好设计分辨率，保证适配市面上大部分机型。 确定游戏的总体框架 (MVC)，整体的游戏框架需要在撸代码之前就要确定下来，游戏如果没有整体的设计模式，会在后期的代码维护上面遇到很大问题。 基础控件的封装，这个一方面可以方便开发，另一方面可以减少冗余代码，在后期统一修改游戏的控件风格时，这种封装的优势就体现出来了。之前的项目，要统一调整按钮的样式，因为没有做封装，导致修改这个按钮样式费时费力。 资源加载和释放，这个问题在游戏开发中是很重要的一环，需要在最开始就考虑好项目的资源管理方式，异步加载资源还是同步加载资源，如果管理资源的释放，是一款游戏的基本素质。虽然这个玩家开不见摸不着，但是对玩家的影响还是比较大的，如果资源加载处理的不好，会导致耗电严重，手机发烫等等的问题。所以不管游戏体量的大小，每个游戏都应该要重视资源管理。 内存峰值的优化，这里有两个点需要注意，一个就是避免内存占用陡增，另一个就是使用的内存要释放，不能有内存泄漏。内存占用陡增一方面是会造成游戏卡顿，另一方面也是会增加崩溃的概率。内存泄漏这个是肯定不能有的，或者说影响不会很严重，不然在游戏运行期间内存占用一直会是增加的情况，最后也是会被系统杀掉进程的。 根据项目实际情况优化游戏性能，这个每个游戏都不一样，根据游戏的实际情况和项目需求对游戏进行优化。例如：图片格式的优化 iOS 使用 PVR，Android 使用 ETC1 等等。 小结 写下这篇文章主要是为了记录下这段时间踩过的坑，遇到的问题，让自己以后碰到类似的情况不至于再踩一次坑。目前能想到的点都写上去了，后续有想到其他的点，或者是新踩的坑，也会尽量更新到这里来。 从零做一款游戏看似简单，但实际上还是会有许多问题。这也让我认识到自己的不足，也学习到了很多知识，果然人还是要踩过坑才知道做事情有难度。 ","link":"https://lzhenhong.github.io/post/cong-ling-kai-shi-zuo-you-xi/"},{"title":"设备卡顿产生的原因","content":"虽然当下的设备越来越强大，处理速度也越来越快，显示效果越来越好。但是如果处理不好，再强大的设备还是会有卡顿的可能性，所以了解卡顿产生的原因是很有必要的。 帧率和刷新率的区别 我们先来看一下显示器是如何显示图像的，CPU 将计算好的内容传递给 GPU，GPU 进行图像处理（GPU 对浮点计算做了优化），GPU 执行渲染之后将内容放入帧缓冲区，显示器需要显示图像时就会经过一系列操作获取帧缓冲区的内容，显示到屏幕上，展示给用户。如下图所示： 接下来开始说帧率和刷新率，帧率指的是 GPU 绘制图片的速度，帧率 60FPS 指的是在 1 秒内绘制 60 张图片。刷新率指的是屏幕 1 秒内显示图片的次数， 刷新率 60Hz 指的是 1 秒内需要显示 60 张图片。我们举几个例子来更好的说明： 如果 GPU 的帧率是 2FPS，显示器的刷新率是 1Hz，这个就会造成 GPU 1 秒内绘制的两张图片只会有一张被显示，因为当显示器第二次从帧缓存区中取图片数据的时候，帧缓存区中已经是 GPU 绘制的第三张图片了，GPU 绘制好的第二张图片被丢弃了。 如果 GPU 的帧率是 1FPS，当显示器的刷新率是 2Hz，GPU 1 秒绘制一张图片，显示器 1 秒要显示两张图片，GPU 1 秒将绘制好的图片放入帧缓存区中，显示器第一次从帧缓存区中取出图片数据显示到屏幕上，当显示器第二次去帧缓存区中取图片时 GPU 才绘制好新一帧的一半，这就造成后面要说的画面撕裂。 屏幕撕裂 屏幕撕裂也是画面撕裂，屏幕撕裂 (Screen Tearing) 是指显示器把两个或更多的帧显示在同一画面上。 显示器的更新频率是固定的，通常是 60Hz。现在显卡效能大幅提高，游戏时输出的帧率可以非常高，如果显卡的输出高于 60FPS，上面我们提到过一个例子 GPU 的绘制速度恰好显示器的刷新速度的两倍，虽然 GPU 和显示器的频率不相同但是也不至于造成屏幕撕裂。但是事实上 GPU 和显示器的组合有很多种可能，如果 GPU 的帧率是 75FPS，显示器的刷新率是 60Hz，也会造成屏幕撕裂。 如何解决屏幕撕裂 多个帧缓冲区 上面提到的屏幕撕裂的例子都是以单个帧缓冲区为前提条件，因为只有一个帧缓冲区，GPU 只能在这个帧缓冲区中绘制图像，就很容易造成上面所说的屏幕撕裂。 引入多个帧缓冲区可以有效地缓解屏幕撕裂，多个帧缓冲区分为帧缓冲区和多个后备缓冲区，GPU 在一个缓冲区绘制完之后，就到下一个缓冲区中绘制，这样 GPU 新绘制的图像帧就不会影响前面的图像帧。显示器每次会从帧缓冲区中取出图像显示，当帧缓冲区的图像显示之后，会将后备缓冲区的图像覆盖到帧缓冲区。 但多个帧缓冲区并不能真正的解决屏幕撕裂的问题，上面说到多个帧缓冲区只能缓解屏幕撕裂。以使用双缓冲区的设备为例，如果后备缓冲区绘制完成，就会开始将后备缓冲区的图像内容覆盖到帧缓冲区，此时帧缓冲区的图像还没有被显示器取出显示，在覆盖期间就会导致帧缓冲区的图像有 GPU 绘制的两帧的内容，如果这个时候显示器从帧缓冲区中取出图像同样会造成屏幕撕裂。 这里当然可以再增加帧缓冲区来解决问题，但是没有真正的解决根本问题，就是 GPU 和显示器的同步问题。为了解决屏幕撕裂的问题，引入了垂直同步（V-Sync），有了这个机制之后就能彻底解决屏幕撕裂。 垂直同步（V-Sync） 上面我们提到的 GPU 的绘制与显示器的显示是完全独立的，中间只通过帧缓冲区来交互。垂直同步就是保证 GPU 的绘制和显示器的显示是同步的，GPU 绘制好的每一帧图像显示器都会显示，不会出现一帧没有显示就被后面的帧覆盖的情况。 垂直同步的工作原理大概是：显示器在处理完当前图像帧，会向 GPU 发送 VSync 信号，当 GPU 接收到 VSync 信号之后，就会进行帧缓冲区的更新和新图像帧的绘制。这样就能保证 GPU 绘制的图像帧不会出现被覆盖的情况，也就解决了屏幕撕裂。 垂直同步理想的工作状态如下图所示： 如上图所示，CPU 和 GPU 能在两个 VSync 信号之间将显示器要显示的图像帧准备完成，就能保证显示器流畅的刷新，我们就不会感受到卡顿的情况。 虽然垂直同步解决了 GPU 和显示器的同步问题，但是垂直同步也是有一定缺点的，显卡的性能再好也得看显示器的 VSync 信号的频率，所以垂直同步会限制 GPU 的性能；并且垂直同步也会消耗更多的计算资源，也会带来部分延迟。现在的设备通常是使用多缓冲区和垂直同步两种方式相结合，目前 iOS 设备使用的双缓冲区加垂直同步机制，Android 设备有使用双缓冲区或者三缓冲区加垂直同步机制。 目前有更好的显示技术可以解决 GPU 和显示器的同步问题：Nvidia 提出的专利技术 G-Sync 以及 AMD 提出开放标准 FreeSync。关于这两个技术可以看：显示器刷新率和显卡fps一定要很匹配吗？ 卡顿的原因 上面我们提到理想状态下，显示器的刷新是流畅的。那在不理想的情况下就会造成要说的卡顿现象，专业的说法就是掉帧 🤨。 从上图可以看出，CPU 和 GPU 在两个 VSync 信号之间不能将显示器要显示的图像帧准备好，就会造成掉帧的情况。如果 CPU 和 GPU 没有将图像帧准备好，这一帧就会被丢弃，等待下一次 VSync 信号的到来。显示屏就会保持当前的显示图像不变，如果这时界面是在不断变化的，我们就会感受到卡顿。 解决卡顿 卡顿产生的原因是因为 CPU 和 GPU 在两个 VSync 信号之间，没有完成显示图像的提交。要解决卡顿就需要了解 CPU 和 GPU 在两个 VSync 信号做了什么事情。 CPU 相关的操作 对象创建 - 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。 对象销毁 - 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。 布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。 解压图片 - PNG 或者 JPEG 压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。 .... GPU 相关的操作 纹理的渲染 - 所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。 视图的混合 - 当多个视图重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。 降低 GPU 性能的事情： 太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。 重绘 - 主要由重叠的半透明图层引起。GPU 的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。 离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于 CPU 或者是 GPU 的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低 GPU 性能。 过大的图片 - 如果视图绘制超出 GPU 支持的 2048x2048 或者 4096x4096 尺寸的纹理，就必须要用 CPU 在图层每次显示之前对图片预处理，同样也会降低性能。 知道了 CPU 和 GPU 做的操作，就可以针对相应的操作来进行优化。例如：限制每一帧对象的创建、优化图片的处理等等。 Tip：GPU 和显卡的区别 GPU 即 Graphic Processing Unit，图像处理器，是整个显卡的核心。显卡是由 GPU、显存等等组成的。大部分情况下，我们所说 GPU 就等于指显卡，但是实际情况是 GPU 是显卡的一个核心组成部分。 相关链接 番外——深入垂直同步机制(VSYNC) 脑洞大开：为啥帧率达到 60 fps 就流畅？ iOS 保持界面流畅的技巧 使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能 CPU VS GPU 显示器刷新率和显卡fps一定要很匹配吗？ 显卡和 GPU 的区别 帧率与刷新率的区别 自适应垂直同步 ","link":"https://lzhenhong.github.io/post/she-bei-qia-dun-chan-sheng-de-yuan-yin/"},{"title":"Objective-C 字面量","content":"有段时间没看关于 iOS 的东西了，前段时间在翻 Instapaper 的时候看到了 NSVALUE AND BOXED EXPRESSIONS 这篇文章，就随便看了看，正好自己对这些也不是很了解，就记录下来。 在 Apple LLVM Compiler 4.0 支持嵌套表达式 (Boxed Expressions)。即可以用 @() 的方式生成相应的对象，例如：@1 相当于 [NSNumber numberWithInt:1];，@1 称为 NSNumber 字面量。ObjC 中还有集合字面量，以及通过下标来访问 OC 对象。下面介绍在 OC 中字面量的使用。 NSNumber 字面量 NSNumber 字面量支持有符号、没有符号的整数 (char, short, int, long, long long)，支持浮点数 (float, double)，也支持布尔值 (BOOL, C++ bool)。在 Objective-C 中，任何字母、数字和布尔值的字面量前面有 @ 都会被当成指向用 @ 后面的值创建的 NSNumber 对象。 void main(int argc, const char *argv[]) { // character literals. NSNumber *theLetterZ = @'Z'; // equivalent to [NSNumber numberWithChar:'Z'] // integral literals. NSNumber *fortyTwo = @42; // equivalent to [NSNumber numberWithInt:42] NSNumber *fortyTwoUnsigned = @42U; // equivalent to [NSNumber numberWithUnsignedInt:42U] NSNumber *fortyTwoLong = @42L; // equivalent to [NSNumber numberWithLong:42L] NSNumber *fortyTwoLongLong = @42LL; // equivalent to [NSNumber numberWithLongLong:42LL] // floating point literals. NSNumber *piFloat = @3.141592654F; // equivalent to [NSNumber numberWithFloat:3.141592654F] NSNumber *piDouble = @3.1415926535; // equivalent to [NSNumber numberWithDouble:3.1415926535] // BOOL literals. NSNumber *yesNumber = @YES; // equivalent to [NSNumber numberWithBool:YES] NSNumber *noNumber = @NO; // equivalent to [NSNumber numberWithBool:NO] #ifdef __cplusplus NSNumber *trueNumber = @true; // equivalent to [NSNumber numberWithBool:(BOOL)true] NSNumber *falseNumber = @false; // equivalent to [NSNumber numberWithBool:(BOOL)false] #endif } NSNumber 只支持数字前面带 @，举个例子： #define INT_MAX 2147483647 /* max value for an int */ #define INT_MIN (-2147483647-1) /* min value for an int */ NSNumber 字面量支持 @INT_MAX，但是不支持 @INT_MIN，因为 INT_MIN 是一个表达式，@INT_MIN 称为嵌套表达式。NSNumber 字面量不支持 long double，所以类似于 @123.23L 这个写法是不合法，编译器会报错。 以前，BOOL 值只是 signed char 的 typedef，YES 是 (BOOL)1，NO 是 (BOOL)0。但是为了支持 @YES 和 @NO 这种写法，这些宏被重新定义： #if __has_feature(objc_bool) #define YES __objc_yes #define NO __objc_no #else #define YES ((BOOL)1) #define NO ((BOOL)0) #endif Objective-C++ 还支持 @true 和 @false 表达式，跟 @YES 和 @NO 是相同的。 嵌套表达式 NSString 现在 iOS 开发中使用 OC 字符串，都可以很简单的创建：NSString *str = @&quot;some string.&quot;;，但是这个其实是 @ 加上一个 C 类型的字符串生成 NSString，这个也就是 NSString 字面量。跟前面的 NSNumber 很像，当 @ 后面跟的表达式是 (char *) 或者是 (const char *) 类型的，这个嵌套表达式的结果就是指向 NSString 对象的指针，这个 NSString 对象跟 C 字符串包含相同的字符，并且是以 \\0 结尾和 UTF-8 编码。有个例子是将 C 字符串风格的命令行参数转成 NSString： // Partition command line arguments into positional and option arguments. NSMutableArray *args = [NSMutableArray new]; NSMutableDictionary *options = [NSMutableDictionary new]; while (--argc) { const char *arg = *++argv; if (strncmp(arg, &quot;--&quot;, 2) == 0) { options[@(arg + 2)] = @(*++argv); // --key value } else { [args addObject:@(arg)]; // positional argument } } 我们需要保证嵌套表达式中的 C 字符串是有效的，不能是 NULL，在运行时传递 NULL 会导致抛出异常。编译器也会尽可能拒绝向嵌套表达式中传递 NULL。 嵌套枚举 尽管枚举值是整数，但是枚举还是不能直接作为嵌套字面量使用，这样是为了避免前缀是 @ 符号的 Objective-C 关键字。枚举值必须放在嵌套表达式中，下面的例子表明了在字典中使用 AVAudioRecorder 枚举： enum { AVAudioQualityMin = 0, AVAudioQualityLow = 0x20, AVAudioQualityMedium = 0x40, AVAudioQualityHigh = 0x60, AVAudioQualityMax = 0x7F }; - (AVAudioRecorder *)recordToFile:(NSURL *)fileURL { NSDictionary *settings = @{ AVEncoderAudioQualityKey : @(AVAudioQualityMax) }; return [[AVAudioRecorder alloc] initWithURL:fileURL settings:settings error:NULL]; } @(AVAudioQualityMax) 这种语法将 AVAudioQualityMax 转换成为整数类型，并转换成相应的值。如果枚举像下面一样申明了类型，则编译器会选择 NSNumber 正确的创建方法： typedef enum: unsigned char { Red, Green, Blue } Color; NSNumber *red = @(Red), *green = @(Green), *blue = @(Blue); // =&gt; [NSNumber numberWithUnsignedChar:] 集合字面量 使用字面量方式创建集合对象，需要注意避免 nil，如果在编译时期发现 nil，编译器会发出警告。在运行时期发现 nil，会抛出错误。 NSArray 使用字面量创建数组 NSArray *array = @[@&quot;Hello&quot;, NSApp, [NSNumber numberWithInt:42]]; 用字面量创建集合对象更加安全。数组字面量语法实际上是调用 +[NSArray arrayWithObjects:count:] 方法，这个方法会保证所有数组中的对象都是非 nil。+[NSArray arrayWithObjects:] 这个方法使用 nil 作为结束符号，可能会造成不可预期的结果。 数组对象还支持 C 语言的下标语法： NSMutableArray *array = ...; NSUInteger idx = ...; id newObject = ...; id oldObject = array[idx]; array[idx] = newObject; // replace oldObject with newObject 访问数组的下标是整数类型，编译器会根据是读取元素还是覆写元素展开成不同的方法。如果是读取元素，则会转换成 objectAtIndexedSubscript: 方法。如果是覆写元素，这会转换成 setObject:atIndexedSubscript: 方法。对于 NSArray 来说，访问 [0, array.count) 之外的位置编译器会抛出异常。对于 NSMutableArray 来说，给范围之内的位置赋值，会替换成这个值，但是给范围之外的位置赋值会抛出异常。没有给可变的数组提供插入、增加、删除元素的语法。 NSDictionary 使用字面量创建字典： NSDictionary *dictionary = @{ @&quot;name&quot; : NSUserName(), @&quot;date&quot; : [NSDate date], @&quot;processInfo&quot; : [NSProcessInfo processInfo] }; 字典字面量也相似，字典字面量使用 +[NSDictionary dictionaryWithObjects:forKeys:count:] 方法来创建字典对象，这个方法会保证所有的键值都非 nil。+[NSDictionary dictionaryWithObjectsAndKeys:] 方法也是使用 nil 来作为结束符。 NSDictionary 的键必须要实现 &lt;NSCopying&gt; 协议，值必须要是 Objective-C 的对象。 字典对象同样支持下标范围元素： NSMutableDictionary *dictionary = ...; NSString *key = ...; oldObject = dictionary[key]; dictionary[key] = newObject; // replace oldObject with newObject 访问字典的下标使用的对象，同样下标语法会根据读取还是覆写翻译成不用的方法。如果是读取元素，则会转换成 objectForKeyedSubscript: 方法。如果是覆写元素，这会转换成 setObject:forKeyedSubscript: 方法。 NSValue NSValue 可以保存任何的数字类，例如：int/float/char，还可以保存对象和结构体，NSValue 永远都是不可变的。NSValue 是一个抽象类，真正发挥作用的是 NSValue 的子类，可以继承自 NSValue 类，但是 NSValue 不为子类提供存储空间，需要子类自己实现。此外，NSValue 子类还需要实现两个简单的方法。任何继承自 NSValue 的子类需要覆写 valueWithBytes:objCType: 和 getValue: 方法，这两个方法需要操作你提供的值的内存空间。NSValue 没有指定初始化函数，所以自定义的初始化函数只需要调用 super 的 init 方法就好了。NSValue 还遵守 NSCopying 和 NSSecureCoding 协议，如果子类需要支持 copying 和 coding，实现这两个协议的方法。 如果需要 NSValue 支持集合，NSValue 还需要重写 hash 方法。 如果你只想使用 NSValue 来包装你的数据结构，你可以不需要创建 NSValue 子类，使用分类是更好的选择。下面定义了 Polyhedron 结构体，并使用 NSValue 的分类方法来获得和储存 Polyhedron 结构体： typedef struct { int numFaces; float radius; } Polyhedron; @interface NSValue (Polyhedron) @property (readonly) Polyhedron polyhedronValue; + (instancetype)valuewithPolyhedron:(Polyhedron)value; @end @implementation NSValue (Polyhedron) + (instancetype)valuewithPolyhedron:(Polyhedron)value { return [self valueWithBytes:&amp;value objCType:@encode(Polyhedron)]; } - (Polyhedron)polyhedronValue { Polyhedron value; [self getValue:&amp;value]; return value; } @end 自定义的 C 结构体支持 Boxed Value 上面说了嵌套表达式支持 NSValue，而 NSValue 是支持结构体的，唯一的要求就是将结构体标记为 objc_boxable。 struct __attribute__((objc_boxable)) Point { // ... }; typedef struct __attribute__((objc_boxable)) _Size { // ... } Size; typedef struct _Rect { // ... } Rect; struct Point p; NSValue *point = @(p); // ok Size s; NSValue *size = @(s); // ok Rect r; NSValue *bad_rect = @(r); // error typedef struct __attribute__((objc_boxable)) _Rect Rect; NSValue *good_rect = @(r); // ok 为了支持老版本的框架或者是第三方框架，需要使用 typedef 来添加这个特性，像这样 typedef struct __attribute__((objc_boxable)) _Rect Rect;。 警告 使用字面量和嵌套表达式创建的对象，在运行时不能保证唯一性，也不能保证是重新分配的内存。因此直接使用地址来判断对象是否相等是有问题的，例如：== \\ != \\ &lt; \\ &lt;= \\ &gt; \\ &gt;= 这些运算符。应该使用 isEqual: 或者 compare: 方法来判断。 还有一点就是要注意检查是否支持新语法： #if __has_feature(objc_array_literals) // new way. NSArray *elements = @[ @&quot;H&quot;, @&quot;He&quot;, @&quot;O&quot;, @&quot;C&quot; ]; #else // old way (equivalent). id objects[] = { @&quot;H&quot;, @&quot;He&quot;, @&quot;O&quot;, @&quot;C&quot; }; NSArray *elements = [NSArray arrayWithObjects:objects count:4]; #endif #if __has_feature(objc_dictionary_literals) // new way. NSDictionary *masses = @{ @&quot;H&quot; : @1.0078, @&quot;He&quot; : @4.0026, @&quot;O&quot; : @15.9990, @&quot;C&quot; : @12.0096 }; #else // old way (equivalent). id keys[] = { @&quot;H&quot;, @&quot;He&quot;, @&quot;O&quot;, @&quot;C&quot; }; id values[] = { [NSNumber numberWithDouble:1.0078], [NSNumber numberWithDouble:4.0026], [NSNumber numberWithDouble:15.9990], [NSNumber numberWithDouble:12.0096] }; NSDictionary *masses = [NSDictionary dictionaryWithObjects:objects forKeys:keys count:4]; #endif #if __has_feature(objc_subscripting) NSUInteger i, count = elements.count; for (i = 0; i &lt; count; ++i) { NSString *element = elements[i]; NSNumber *mass = masses[element]; NSLog(@&quot;the mass of %@ is %@&quot;, element, mass); } #else NSUInteger i, count = [elements count]; for (i = 0; i &lt; count; ++i) { NSString *element = [elements objectAtIndex:i]; NSNumber *mass = [masses objectForKey:element]; NSLog(@&quot;the mass of %@ is %@&quot;, element, mass); } #endif #if __has_attribute(objc_boxable) typedef struct __attribute__((objc_boxable)) _Rect Rect; #endif #if __has_feature(objc_boxed_nsvalue_expressions) CABasicAnimation animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; animation.fromValue = @(layer.position); animation.toValue = @(newPosition); [layer addAnimation:animation forKey:@&quot;move&quot;]; #else CABasicAnimation animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;]; animation.fromValue = [NSValue valueWithCGPoint:layer.position]; animation.toValue = [NSValue valueWithCGPoint:newPosition]; [layer addAnimation:animation forKey:@&quot;move&quot;]; #endif 参考链接 Objective-C Literals NSVALUE AND BOXED EXPRESSIONS Objective-C LLVM 4.0 的新特性 NSValue Class ","link":"https://lzhenhong.github.io/post/objective-c-zi-mian-liang/"},{"title":"Cocos 的初级小坑","content":"又是很久没有写博客了，所以再次写一篇来凑凑字数 😜，主要还是把自己最近刚知道的知识记录下来，方便以后来查看。 因为开始做游戏开发，所以就开始学习 Cocos 相关的内容。最近在几个地方踩了坑，虽然是很小的知识点，但是记录下来也算是记录成长的历程 😶😶。 ignoreContentAdaptWithSize 这个其实不能算踩的坑，主要是当时看到这个觉得很奇怪，因为原来有做过 iOS 开发，觉得这种方式不能理解，当时在项目中看到这个代码的时候也是纠结了蛮久的，前段时间实在不爽，就把这个大概了解了下。因为 Cocos 是开源的，所以，要了解一个函数的详细用法，除了上网 Google 以外，还可以看源码。这在开发 iOS 是做不到的，虽然 iOS 的官方文档超级详细，但还是没有源码来的清晰。 这个方法是 ccui.Widget 的方法，在文档中的描述就是会触发控件是否忽略自定义的 contentSize，在这个类中这个方法的定义如下： ignoreContentAdaptWithSize: function(ignore) { if (this._unifySize) { this.setContentSize(this._customSize); return; } if (this._ignoreSize === ignore) return; this._ignoreSize = ignore; this.setContentSize(ignore ? this.getVirtualRendererSize() : this._customSize); } 在这个方法的实现中，我们可以看到，在最后一行代码根据传递的 bool 值来判断是否使用自定义的 contentSize 值，其实在 setContentSize 方法中也会根据 this._ignoreSize 来判断是否使用自定义的 contentSize，这里在改变了 this._ignoreSize 的值之后，要触发 setContentSize 方法来改变控件的 contentSize。在 ccui.Widget 中会在初始化时调用这个方法，并传递 true，意味着继承自 ccui.Widget 的控件默认都会使用 getVirtualRendererSize 方法返回的 contentSize 来作为控件的大小。 关于 getVirtualRendererSize 方法，每个控件的实现方式不同，下面举两个控件的实现方式： // UIButton.js:180 getVirtualRendererSize: function() { if (this._unifySize) return this._getNormalSize(); if (!this._normalTextureLoaded) { if (this._titleRenderer &amp;&amp; this._titleRenderer.getString().length &gt; 0) { return this._titleRenderer.getContentSize(); } } return cc.size(this._normalTextureSize); } 从 Button 的实现可以看出，在忽略 this._unifySize 的情况下，如果 Button 没有加载过纹理，就用设置的文字的大小来作为 Button 的大小。如果加载过纹理，则使用纹理的 contentSize 来作为 Button 的 contentSize。 // UIText.js:341 getVirtualRendererSize: function() { return this._labelRenderer.getContentSize(); } Text 的实现方式相比于 Button 就更简单了，直接使用文字的大小来设置 Text 的大小。 强行小结 在使用 ccui.Widget 的控件时，在控件大小需要跟图片大小、文字大小等相同时，我们就可以不用管这个方法，因为在初始化时就会调用此方法并传递 true。如果我们需要自定义控件的 contentSize，就需要手动调用这个方法，并传递 false，这样我们设置的 contentSize 才会生效。可以使用 isIgnoreContentAdaptWithSize 方法来获取是否忽略自定义的 contentSize。其实大部分情况下，默认方式就能满足我们的需求，这样也算是提高了一点点效率吧。 ignoreAnchorPointForPosition 这算是结结实实踩的坑，在这个地方浪费了蛮多时间的，因为在界面上控件显示不出来，也不能像 iOS 开发那样有 Reveal 这样的工具，所以只能一点点去打印，但是打印的锚点依然是 (0.5, 0.5)。WTF 🙄 这个方法是在 Node 中定义的，这个方法在文档中的描述是：控制在设置 Node 位置时，锚点是否是始终为 (0, 0)；文档还说这个方法是内部使用的方法，只在 Layer 和 Scene 中使用，不要在外部调用此方法。在 Node 中的具体定义如下： ignoreAnchorPointForPosition: function(newValue) { if (newValue !== this._ignoreAnchorPointForPosition) { this._ignoreAnchorPointForPosition = newValue; this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty); } } 这个方法会先设置 this._ignoreAnchorPointForPosition 的值，这个值在 Node 中默认为 false，但是在 Layer 和 Scene 中为 true。在 CCNode.js:157 中的注释描述到占据整个屏幕的控件像 Layer 和 Scene 需要将这个值设为 true。随后设置 CCNodeCanvasRenderCmd 的 flag，需要重新改变控件的 transform，在 CCNodeCanvasRenderCmd 的 setDirtyFlag 方法中，会将这个 CCNodeCanvasRenderCmd 放入 cc.renderer 的 _transformNodePool 中，随后在 cc.renderer 的 transform 方法中遍历 _transformNodePool 调用 CCNodeCanvasRenderCmd 的 updateStatus 方法，在 CCNodeCanvasRenderCmd 的 updateStatus 方法中调用 CCNodeCanvasRenderCmd 的 transform 方法，在这个方法中根据一些设置，其中包括 node 的 _ignoreAnchorPointForPosition 来调整 node 的锚点。 强行小结 在大多数情况下，计算控件的位置都会受到锚点的影响。并且默认情况下，锚点的值都是 (0.5, 0.5)。但是还是有特殊情况的，虽然锚点是 (0.5, 0.5)，但是 this._ignoreAnchorPointForPosition 为 true，这样控件的位置就不受锚点的影响。Layer 跟 Scene 都是这样，设置锚点为 (0.5, 0.5)，但是同样设置了 this._ignoreAnchorPointForPosition 为 true。继承自这两个控件的控件也会有这样的问题，例如：ScrollView 和 TableView，设置锚点对这两个控件的位置计算没有影响。需要锚点有影响的话就需要调用 ignoreAnchorPointForPosition 方法，并传递 true。 可以使用 isIgnoreAnchorPointForPosition 函数来获取 this._ignoreAnchorPointForPosition 的值。锚点只影响自身的位置，子控件始终以父控件的左下角为坐标原点。 cc.TableView 关于 TableView 的坑，上面介绍的算一个，然后还有就是设置 TableView 的大小时，不能使用 setContentSize 去设置 TableView 的大小，TableView 继承自 ScrollView，其实这个是 ScrollView 的实现方式。在 iOS 中，设置控件大小的时候使用的是 frame，contentSize 是 UIScrollView 的特有属性，表示 UIScrollView 可滚动的区域大小。在 Cocos 中设置控件的大小使用的是 contentSize，但是在 ScrollView 和 TableView 这，contentSize 的含义变了，也是跟 iOS 中的 contentSize 相似，代表可滚动的区域大小。 看下 ScrollView 中的 setContentSize 函数的实现： setContentSize: function(size, height) { if (this.getContainer() !== null) { if (height === undefined) this.getContainer().setContentSize(size); else this.getContainer().setContentSize(size, height); this.updateInset(); } } 这里的 setContentSize 方法不会直接设置 ScrollView 的 contentSize，而是设置 container 的 contentSize，这个 container 默认是 Layer，代表 ScrollView 的内容。setContentOffset 改变的也是 container 的 position，所以 setContentSize 不能改变 ScrollView 和 TableView 的可视区域。改变可视区域的方法是 setViewSize，实现如下： setViewSize: function(size) { this._viewSize = size; cc.Node.prototype.setContentSize.call(this, size); } 在创建 TableView 和 ScrollView 的时候，传递的 cc.size 就是可视区域的大小，如果没有给可视区域的大小，默认是 cc.size(200, 200)。 强行小结 虽然 Cocos 的 TableView 和 ScrollView 跟 iOS 中的 UITableView 和 UIScrollView 有很多相似的地方，但是还是有很多不同点，不能简单的以 iOS 中的方式来带入到 Cocos 中。 ScrollView 和 TableView 设置可视区域的函数是 setViewSize，设置内容大小的函数是 setContentSize。 不同对象引用同一对象 这个算是 JS 层面的坑，在 Cocos-JS 中采用的是 John Resig's Simple Class Inheritance 继承来实现的。我们来看一下在 Cocos-JS 的自定义 Node 的实现方式： var MyNode = (function() { var node = cc.Node.extend({ data_: [], ctor: function() { this._super(); // do something with data_. }, onExit: function() { // release resources. this._super(); } }); return node; })(); 上面这段代码看起来是没有什么问题的，但是我们如果创建多个 MyNode 对象，并同时对 data_ 进行了一些操作，我们就会发现 data_ 的数据跟我们预想的数据不太一样。这是因为这两个对象的 data_ 实际上实际上是同一个对象，这就导致其中一个 MyNode 对象对 data_ 进行了操作会影响到另一个对象的 data_ 数据。可以通过下面的方式来避免这个情况的发生： var MyNode = (function() { var node = cc.Node.extend({ data_: null, ctor: function() { this._super(); this.data_ = []; // do something with data_. }, onExit: function() { // release resources. this._super(); }, }); return node; })(); 一个类的属性如果是 array / function / object，这个属性的初始化需要放到 ctor 方法中。 相关链接 cocos2d-x AnchorPoint 锚点 菜鸟学习Cocos2d-x 3.x——锚点 Cocos2d-x JSB + Cocos2d-html5 跨平台游戏开发（一）—— 引擎选择 Cocos2d-x JSB + Cocos2d-html5 跨平台游戏开发（二）—— 遇到的坑 ","link":"https://lzhenhong.github.io/post/cocos-de-chu-ji-xiao-keng/"},{"title":"Javascript 中的 apply/call/bind 函数","content":"有很长一段时间没有写博客了，前一段时间做毕设，写论文，改论文，答辩，拍毕业照... 很多很多不喜欢的事情，再加上那段时间沉不下心，就很少有机会去写博客了。 这周一刚进公司，开始做游戏，原来对游戏开发也不太了解，进公司这几天也一直都在学习各种东西，JS 语法，常见的 Cocos API 等等。今天在看 Cocos 的东西时，对 Cocos 的继承不是很了解，就去网上搜资料，在看 John Resiq 的继承写法解析的时候，对 apply 函数的用法不是很了解，于是又去查资料，这篇博客主要是记录自己对三个函数的理解，也让自己开始继续写博客。 关于这些函数网上的解析数不胜数，我这个 JS 方面的 green-hand 来写这三个函数，主要还是记录下自己的理解。 这三个函数，其中 apply 与 call 函数的作用基本相同，就是改变某个函数运行时的上下文，只是这两个函数接收参数的方式不同。apply 函数接收的参数是包含多个参数的数组，call 函数接收的参数类型是多个参数的列表。 apply 函数的调用方式：func.apply(thisArg, [argsArray]) call 函数的调用方式：func.call(thisArg, arg1, arg2, ...) apply 与 call 的相同点 从上面的两个函数的调用方式，就能得知这两个函数都是 JS 中函数对象原型 (prototype) 的方法。来看一下这两个函数的具体用法： apply 函数的用法 这个函数接收两个参数，第一个参数代表需要替换的上下文对象，第二个参数代表调用对象的参数数组。 不带参数的函数使用 apply ： var name = &quot;lzh&quot;; var o = { name: &quot;eden&quot; }; function printName() { console.log(this.name); } printName(); // log: lzh printName.apply(o); // log: eden 多个参数的函数使用 apply，将多个参数打包成数组作为第二个参数传入 apply 函数： var name = &quot;lzh&quot;; var o = { name: &quot;eden&quot; }; function printHello(greeting, address) { console.log(greeting + &quot;: &quot; + this.name + &quot;, Live in: &quot; + address); } printHello(&quot;Hello. My name is&quot;, &quot;ShenZhen&quot;); // Hello. My name is: lzh, Live in: ShenZhen printHello.apply(o, [&quot;Hello. My name is&quot;, &quot;ShenZhen&quot;]); // Hello. My name is: eden, Live in: ShenZhen call 函数的用法 这个函数接收多个参数，参数不限，第一个参数跟 apply 函数的第一个参数相同，代表要替换掉的上下文对象，后面的参数都是调用函数的参数。 不带参数的函数使用 call，这里跟 apply 的使用基本上没有区别： var name = &quot;lzh&quot;; var o = { name: &quot;eden&quot; }; function printName() { console.log(this.name); } printName(); // log: lzh printName.call(o); // log: eden 多个参数的函数使用 call，这里跟 apply 有不同，调用函数的参数传入方式，apply 函数是利用数组，call 函数的参数是需要逐个传入： var name = &quot;lzh&quot;; var o = { name: &quot;eden&quot; }; function printHello(greeting, address) { console.log(greeting + &quot;: &quot; + this.name + &quot;, Live in: &quot; + address); } printHello(&quot;Hello. My name is&quot;, &quot;ShenZhen&quot;); // Hello. My name is: lzh, Live in: ShenZhen printHello.call(o, &quot;Hello. My name is&quot;, &quot;ShenZhen&quot;); // Hello. My name is: eden, Live in: ShenZhen apply 与 call 的不同点 其实从上面两个函数的用法就可以看出来，两个函数的作用是相同的，就是改变函数执行的上下文对象，只是在有多个参数函数的用法上有区别。在参数个数不确定的情况下，就使用 apply 函数；在参数确定的情况下，使用两个函数都可以。 我们看一个**面试题**来看一下这两个函数的具体区别。这个面试题的题目是：「定义一个 log 函数，然后它可以代理 console.log 的方法」。我们首先想到的是在 log 函数中直接调用 console.log 方法，这种方式在只有一个参数的情况下能满足要求，但是有个参数，这个方式就只能打印第一个参数。 function log(msg) { console.log(msg); } log(&quot;lzh&quot;); // lzh log(&quot;lzh&quot;, &quot;eden&quot;); // lzh 更好的方式是使用 apply 函数，将 log 函数的隐藏参数 arguments 作为参数传递给 console.log 函数。下面代码是实现方式： function log() { // 在这里我有将参数列表中的 console 替换成其他对象，结果虽然是正确的 // 但是最好还是使用 console，因为不知道函数内部究竟有没有使用 console console.log.apply(console, arguments); } log(&quot;lzh&quot;, &quot;eden&quot;); // lzh eden 这道面试题还有一部分：在每次输出的时候，在每一个 log 消息前添加一个 &quot;(app)&quot; 的前辍。 function log() { // var args = [].slice.call(arguments); var args = Array.prototype.slice.call(arguments); // 这里使用 apply 也是可以的 args.unshift('(app)'); console.log.apply(console, args); }; bind 函数 首先我们来看下面的代码： var o = { name: &quot;lzh&quot;, printName: function() { console.log(this.name); } }; o.printName(); // lzh var name = &quot;eden&quot;; var f = o.printName; f(); // eden 从上面的输出结果就可以看出，将对象 o 的 printName 属性赋值给 f，再调用 f，此时输出的结果就不一样了，这是因为当调用 f 函数的时候，会查找。如果我们需要函数的上下文是某个指定的上下文对象，我们就需要使用 bind 来对函数进行一些操作。可以利用上面提到的 apply ／ call 函数，但是这两个函数会立马执行。在本节提到 bind 函数会生成新的函数，不会马上执行。 上面的例子可以使用下面的代码来解决，这时 f 函数的上下文对象就是 o 而不是全局对象： var o = { name: &quot;lzh&quot;, printName: function() { console.log(this.name); } }; o.printName(); // lzh var name = &quot;eden&quot;; var f = o.printName.bind(o); f(); // lzh bind 函数的主要作用是创建绑定函数，使得这个函数不管怎么调用始终具有相同的 this 值。就像上面的示例代码。 我原来以为 JS 中的函数中的对象都是在执行时才确定的，直到看到这篇文章 JavaScript 深入之词法作用域和动态作用域，才意识到自己原来的理解错了。在 Function.prototype.bind() 有一段话： bind() 最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，希望方法中的 this 是原来的对象。（比如在回调中传入这个方法）如果不做特殊处理的话，一般会丢失原来的对象。 这样的话并不能直接理解为 JS 函数的上下文对象是在调用时决定的，相反 JS 的作用域是采用静态作用域，函数的作用域是基于函数创建的位置。下面的例子就能证明： // 来自 https://github.com/mqyqingfeng/Blog/issues/3 var value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar(); // 1 上下文切换导致对象丢失 至于在 Cocos-JS 开发中经常使用的回调会导致上面说的对象的丢失，这种情况跟上面代码中的情况不同，因为这里涉及了函数执行上下文的问题，而不仅仅只是一个变量。在 JavaScript 深入之执行上下文栈 提到 JS 引擎会创建一个上下文调用栈，每当一个函数执行时，会向这个栈中压入当前上下文。每个上下文都有三个重要的属性，如下图：变量对象、作用域链和 this，只有进入上下文中，这个上下文的变量对象才可以被访问。 // HTTPService.js var httpService = (function() { var service = {}; service.getData = function(callback) { if (callback) { callback(data); // 1 } }; return service; })(); // Test.js var mainView = cc.Node.extend({ data_: null, onEnter: function() { this._super(); var self = this; // 2 httpService.getData(function(data) { // this.data_ = data; self.data_ = data; }); } }); 假设在 mainView 的 onEnter 方法中发送网络请求获取数据，因为网络请求是异步的，所以我们获取数据之后的操作需要以回调的方式实现。这个回调的调用是在 HTTPService.js 类中注释 1 那，但是在回调中如果像注释那里那样 this.data_ = data; 这样实现会有问题，因为在 HTTPService.js 类中，上下文已经切换了，所以 this 值不再是 Test.js 中的 this 值，因此会报错，this 获取不到 data_。如果像注释 2 那样写，self 不再依赖上下文，当调用回调时，需要使用 self，会到注释 2 获取，而不是直接取当前上下文的值，这是因为 JS 使用的是静态作用域。当然还可以像下面这样使用 bind 来实现，这样回调里面的 this 一直就会是 Test.js 中的 this。 // Test.js var mainView = cc.Node.extend({ data_: null, onEnter: function() { this._super(); httpService.getData(function(data) { this.data_ = data; }.bind(this)); } }); bind 函数小提示 在深入浅出妙用 Javascript 中 apply、call、bind这篇博客中还提到，多次使用 bind 函数没有效果，看下面的例子： // 来自 http://www.cnblogs.com/sanshi/archive/2009/07/08/1519036.html var bar = function() { console.log(this.x); }; var foo = { x: 3 }; var sed = { x: 4 }; var func = bar.bind(foo).bind(sed); func(); // 3 var fiv = { x: 5 }; var func = bar.bind(foo).bind(sed).bind(fiv); func(); // 3 总结 关于这三个函数的主要作用就是改变函数的上下文对象，其中 apply 和 call 函数会立马执行函数，这两个函数的区别就是接收的参数类型不同；而 bind 函数会生成新的函数，这在函数的回调非常有用。 关于 JS 的继承，可以参考 JavaScript 继承详解，这一系列文章对 JS 的继承介绍得很详细。 相关链接 深入浅出妙用 Javascript 中 apply、call、bind JavaScript 深入之词法作用域和动态作用域 JavaScript 深入之执行上下文栈 JavaScript 深入之变量对象 JavaScript 深入之作用域链 Function.prototype.apply() Function.prototype.call() Function.prototype.bind() John Resiq 的继承写法解析 JavaScript 继承详解 ","link":"https://lzhenhong.github.io/post/javascript-zhong-de-apply-call-bind-han-shu/"},{"title":"ARC 的内存管理","content":"ObjC 是使用引用计数来管理对象内存的，关于引用计数更加详细的解释，可以看 理解 iOS 的内存管理，这篇文章还讲了 ARC 下可能存在的内存管理问题。 ARC 是编译器的特性，在编译的时候自动插入管理引用计数的代码，给 ObjC 对象提供自动内存管理，并生成相应的 dealloc 方法。ARC 可以让你更加专注于编写代码的逻辑而不是去管理内存，但是在 ARC 下遵循 ObjC 的命名规则就显得很重要了。 ARC 下内存管理变量关键字 在 ARC 下，虽然编译器帮我们做了大部分的内存管理的工作，但是我们还是要了解在 ARC 下的内存管理关键字。 __strong 对一个对象进行强引用，表示拥有该对象，就像在 MRC 下进行 retain 是一样的，当一个对象没有强引用指针引用时，这个对象就再不被拥有，这时这个对象就会被销毁。 NSObject * __strong objc = [[NSObject alloc] init]; == NSObject * objc = [[NSObject alloc] init]; 在 ARC 下，默认的指针就是强引用指针。 __weak 对一个对象进行弱引用，不会拥有该对象，不会改变这个对象的内存周期，即不会改变该对象的引用计数。当被引用的对象被销毁时，weak 指针会自动置空，这样就可以避免野指针访问错误。常用来解决循环引用问题。 __typeof__(self) __weak weakSelf = self; __weak 只在 iOS 5 以上版本可用，iOS 5 以下的版本用随后介绍的 __unsafe_unretained。 __unsafe_unretained 跟 __weak 相似，不会拥有指向的对象。但是指向的对象被销毁时不会置 nil，就会变成悬挂指针，即会发生野指针错误。 __typeof__(self) __unsafe_unretained weakSelf = self; 在现在的 iOS 版本下，这个内存管理关键字几乎没有用处，因为 __weak 总是更好的选择。但是如果你想在结构体中声明一个对象的成员变量，你就需要用到这个关键字来避免 Xcode 的编译错误，但是这样你就得花精力去管理这个成员变量的内存周期，所以使用类去实现是更好的选择。 __autoreleasing 使用这个关键字主要为了延长对象的存活周期，不要被过早的销毁。这个关键字常用来声明对象的指针。 NSError * __autoreleasing error = nil; 即使我们没有使用 __autoreleasing 声明，编译器还是会在编译器时期帮我们自动添加。 NSError *error; NSError *__autoreleasing tempError = error; [data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]； 在这里有个问题需要注意： - (BOOL)doSomethingWithDictionary:(NSDictionary *)dictionary error:(NSError * __autoreleasing *)error { // NSError * __block temp = nil; [dictionary enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { // do sth with key &amp; obj if (error &amp;&amp; [some error happened]) { *error = [NSError errorWithDomain:@&quot;TestError&quot; code:1 userInfo:nil]; // tempError = [NSError errorWithDomain:@&quot;TestError&quot; code:1 userInfo:nil]; } }]; if (error) { // *error = tempError; } } 上面的代码看着好像没有什么问题，但是在 enumerateKeysAndObjectsUsingBlock: 的 block 里，会自动创建一个 @autoreleasepool {}， 当离开此次遍历，error 就会被释放掉，最后就不能得到想要的 error 信息。 可按照上面注释掉的代码解决。 ARC 内存管理问题 虽然 ARC 的出现让我们不需要花太多的精力在内存管理上，但是有些内存管理问题 ARC 还是没有办法处理的。例如：循环引用和 Core Foundation。 循环引用 循环引用就是两个对象相互强引用对方，造成两个对象都不能被释放，从而引起内存泄漏。 block 的循环引用 在 block 的使用中是最容易发生内存泄漏的地方，一个对象拥有这个 block，但是在这个 block 里又用到了该对象，block 会持有内部引用的对象，这样就会发生循环引用。 在 block 中有两种方式来解决循环引用的问题： 主动断开循环引用：在 block 使用完，主动将 block 清空，这样就可以断开 block 对内部持有对象的强引用，也就断开了循环引用。 self.completionBlock = nil; 使用弱引用：弱引用不会影响引用对象的内存管理周期，并且在引用对象销毁时置 nil。 __typeof(self) __weak weakSelf = self; self.completionBlock = ^{ __typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) { // do something with self } }; NSTimer NSTimer Class Reference 指出 NSTimer 会强引用 target。并且官方的 Timer Programming Topics 指出： 我们不应该在 dealloc 中 invalidate timer。 举一个例子，我们让 timer 在我们的 ViewController 中不断调用 handleTimer 方法. .h @property (nonatomic, strong) NSTimer *timer; .m - (void)viewDidLoad { [super viewDidload]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(handleTimer:) userInfo:nil repeats:YES]; } 这个时候，timer 和我们的 ViewController 就是循环引用的。即使我们在 dealloc 方法中 invalidate timer 也是没用的。因为 timer 强引用着 VC。而 dealloc 是在对象销毁的时候才会被调用。 即使 VC 对 NSTimer 没有一个强引用，还是有可能会发生内存泄漏，如果一个 timer 添加到 runloop 中，runloop 会对 NSTimer 有一个强引用，如果我们不主动 invalidate timer 的话，runloop 持有 timer，timer 对 VC 也有一个强引用，就会导致内存泄漏。 Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop. 因此在使用 NSTimer 时，特别是循环的 NSTimer 时。我们需要注意在什么地方 invalidate 计时器，在上面这个例子，我们可以在 viewWillDisappear 里面做这样的工作。 performSelector 在 iOS 内存管理机制 这篇文章中还提到了使用 performSelector 可能存在的内存泄漏。 编译器不知道即将调用的 selector 是什么，不了解方法签名和返回值，所以编译器无法用 ARC 的内存管理规则来判断返回值是否应该释放。因此，ARC 采用了比较谨慎的做法，不添加释放操作，即在方法返回对象时就可能将其持有，从而可能导致内存泄露。 Core Foundation ARC 不会去管理 Core Foundation 的对象，但是我们在 ARC 下编写代码也不可避免会碰到 Core Foundation 的对象，所以知道一定的 Core Foundation 内存管理对开发这很有帮助的。 关于 Core Foundation 的内存管理：Memory Management Programming Guide for Core Foundation ARC 下的 dealloc 方法 移除通知中心 (NSNotificationCenter) 的观察者：从 iOS 9 开始，不再需要移除通知中心 (NSNotificationCenter) 的观察者。如果你的 App 依然支持 iOS 8，你还是需要移除观察者。 More details: NSNotificationCenter automatic reregistration 移除 KVO 观察者 释放一些 Core Foundation 的对象 不允许主动调用此方法，runtime 会在对象被销毁之前调用此方法。当应用直接结束的时候，对象可能不会接收到 dealloc 方法。 在 ARC 下不需要也不允许编写 [super dealloc];，因为 ARC 下 runtime 会处理好父类的 dealloc 链；但是在 MRC 下必须要在 dealloc 方法的最后调用 [super dealloc]; 来执行父类的清理操作。 扩展阅读 Simple Memory Management iOS夯实：内存管理 iOS 内存管理机制 iOS 与 OSX 内存管理：引用计数 相关链接 Transitioning to ARC Release Notes iOS ARC 内存管理要点 Natural Code Just Works Advanced Memory Management Programming Guide ","link":"https://lzhenhong.github.io/post/arc-de-nei-cun-guan-li/"},{"title":"实现 NSFastEnumeration","content":"关于 NSFastEnumeration 的基本介绍可以看这篇 使自定义的类支持 iOS 的枚举方式。 不多说废话，直接进主题。 内部实现 要实现 NSFastEnumeration 协议，我们先看下内部实现，将下面的代码 clang -rewrite-objc main.m 成 C++ 代码。 NSArray *array = @[@1, @2, @3]; for (NSNumber *number in array) { NSLog(@&quot;%@&quot;, number); } 得到的 main.cpp 文件，我将代码改了一下，看起来比较友好一点。 NSArray *array = @[@1, @2, @3]; NSNumber *number; // NSFastEnumerationState struct __objcFastEnumerationState enumState = { 0 }; // stackbuf id __rw_items[16]; id l_collection = (id)array; // 调用 countByEnumeratingWithState:objects:count: 方法 _WIN_NSUInteger limit = [l_collection countByEnumeratingWithState:&amp;enumState objects:(id *)__rw_items count:(_WIN_NSUInteger)16]; // 判断是否遍历完毕，每次返回的是一个 C 数组，如果是 0 的话就不遍历 if (limit) { unsigned long startMutations = *enumState.mutationsPtr; // 不停的调用 countByEnumeratingWithState:objects:count: 方法，直到遍历完成 do { unsigned long counter = 0; // 遍历获得的数组 do { if (startMutations != *enumState.mutationsPtr) { // 判断数组是否被改变 objc_enumerationMutation(l_collection); // 抛出异常 } number = (NSNumber *)enumState.itemsPtr[counter++]; NSLog(@&quot;%@&quot;, number); } while (counter &lt; limit); } while (limit = [l_collection countByEnumeratingWithState:&amp;enumState objects:(id *)__rw_items count:(_WIN_NSUInteger)16]); number = ((NSNumber *)0); } else { number = ((NSNumber *)0); } 从上面的代码中我们看到内部实现，两个 do-while 循环去遍历容器对象。第一个 do-while 循环是不断调用 countByEnumeratingWithState:objects:count: 判断返回的数值，查看容器对象是否遍历完成。第二个 do-while 是去遍历 enumState 中 itemPtr 指向的 C 数组。我们可以将容器对象中的元素分成多次通过 C 数组返回，这里 itemPtr 和 countByEnumeratingWithState:objects:count: 返回的数值组成第二个 do-while 循环要遍历的 C 数组。 编码实现 NSFastEnumeration 协议 在看过内部实现之后，我们在实现 countByEnumeratingWithState:objects:count: 方法的时候就知道如何编写代码。 实现 countByEnumeratingWithState:objects:count: 方法有两种方式，一种是容器对象中的元素在内存存储是连续的，那么可以将 NSFastEnumerationState 的 itemPtr 直接设成这个容器的首地址，但是注意必须要是 C 数组。另一种是内存存储中不是连续的，例如：链表，这时候就需要用到 countByEnumeratingWithState:objects:count: 提供的 stackbuf 数组，同时 state-&gt;itemPtr = stackbuf; 接下来看下具体代码实现： 在内存空间中是连续的 @interface TestArray: NSObject @end @implementation TestArray { std::vector&lt;NSNumber *&gt; _numberList; } - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len { // 一次性将所有的元素都返回 if (state-&gt;state == 0) { // 1 __unsafe_unretained const id *const_array = _list.data(); state-&gt;itemsPtr = (__typeof__(state-&gt;itemsPtr))const_array; // 2 state-&gt;state = 1; // 3 state-&gt;mutationsPtr = &amp;state-&gt;extra[0]; // 4 return _numberList.size(); // 5 } else { return 0; // 6 } } @end 利用 NSFastEnumeration 的 state 来判断是否是第一次调用 countByEnumeratingWithState:objects:count: 方法，在前面的 C++ 代码中，我们看到第一次调用此方法的时候，NSFastEnumeration 结构体都被初始化成 0； 将内部容器对象转换成 C 数组，然后设置给 NSFastEnumeration 的 itemPtr 成员； 将 NSFastEnumeration 的 state 设置成 1，代表不是第一次调用此方法； 令 mutationsPtr 设成固定值，这里没有对遍历容器对象改变做保护； 返回 itemPtr 指向的 C 数组的长度； 返回 0 表示遍历已经完成。 在内存空间中是不连续的 @interface TestLinkedList: NSObject @end @implementation TestLinkedList { struct Node *head; } - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len { if (state-&gt;state == 0) { state-&gt;mutationsPtr = &amp;state-&gt;mutationsPtr; state-&gt;extra[0] = (long)head; // 1 state-&gt;state = 1; } struct Node *currentNode = (struct Node *)state-&gt;extra[0]; NSUInteger count = 0; state-&gt;itemsPtr = stackbuf; // 2 while (currentNode &amp;&amp; count &lt; len) { // 3 *stackbuf++ = currentNode-&gt;value; currentNode = currentNode-&gt;next; count++; } if (currentNode) { state-&gt;extra[0] = (long)currentNode-&gt;next; // 4 } return count; } @end 这里的例子是从 Implementing Fast Enumeration 复制过来的。 第一次遍历的时候将 head 存进 extra，原因下面解释； 因为这里是不连续的内存空间，所以我们需要用到 stackbuf 数组，将 itemPtr 指向 stackbuf 数组； 这里不仅要判断当前的节点是否为 NULL，还要判断是否超出了 stackbuf 的长度，这也是为什么要将节点存入 extra 的原因，因为有可能不能一次性遍历完成； 将当前节点的下一个节点存入 extra，以便下一次调用 countByEnumeratingWithState:objects:count: 的时候使用。 更多 更多示例：Implementing Fast Enumeration 和 FastEnumerationSample. 需要注意的是在 Implementing Fast Enumeration 这篇文章中利用 state-&gt;mutationsPtr = (unsigned long *)self; 来确保容器对象不会被改变是有一点问题的，关于这个有人在 Twitter 上说了。如果使用了 isa-swizzling，就可能会出现问题，所以使用 state-&gt;mutationsPtr = &amp;state-&gt;extra[0]; 或者 state-&gt;mutationsPtr = &amp;state-&gt;mutationsPtr; 是比较好一点的选择。 相关链接 Implementing Fast Enumeration Does anyone know how to implement the NSFastEnumeration protocol? Implementing countByEnumeratingWithState:objects:count: Objective-C Fast Enumeration 的实现原理 ","link":"https://lzhenhong.github.io/post/shi-xian-nsfastenumeration/"},{"title":"使自定义的类支持 iOS 的枚举方式","content":"事先可以看一下 Comparison of Objective-C Enumeration Techniques 和 NSFastEnumeration / NSEnumerator，对比了 ObjC 中各种遍历方式。 在 iOS 中主要有 4 种类型的遍历： C 语言风格 NSEnumerator 基于 block 的遍历 NSFastEnumeration C 语言风格 NSArray *nums = @[@1, @2, @3]; for (int i = 0; i &lt; nums.count, ++i) { NSLog(@&quot;%@&quot;, nums[i]); } 形如上面这样的利用 for 循环，然后使用下标去访问对象的方式，就是 C 语言风格的遍历。 要支持这种 C 语言风格遍历就需要实现 objectAtIndexedSubscript: 方法，这是因为编译器会将 someArray[0] 解析成 [someArray objectAtIndexedSubscript:0]。 @interface TestArray: NSObject - (id)objectAtIndexedSubscript:(NSUInteger)idx; @end @implementation TestArray { std::vector&lt;NSNumber *&gt; _numberList; } - (id)objectAtIndexedSubscript:(NSUInteger)idx { if (idx &gt;= _numberList.size()) { // 抛出异常 } return _numberList[idx]; } @end 如果要支持使用键作为下标来访问值，就需要实现 objectForKeyedSubscript: 方法。 NSEnumerator NSArray *numberArray = @[@1, @2, @3]; NSEnumerator *enumerator = [numberArray objectEnumerator]; NSNumber *number; while (number = [enumerator nextObject]) { // 对 number 对象进行操作 } 这是 ObjC 原来遍历集合的标准方式，但是这种写法很冗长。虽然现在基本上不用这种方式了，还是来看一下如何支持这种方式的遍历。 要支持这种遍历方式主要还是实现一个 objectEnumerator 方法返回 NSEnumerator 对象。这里的 NSEnumerator 是抽象类，需要继承 NSEnumerator 然后实现 -nextObject: 方法。 @interface TestEnumerator: NSEnumerator @property (nonatomic, readonly) TestArray *array; - (instancetype)initWithTestArray:(TestArray *)array; @end @implementation TestEnumerator { NSUInteger _currentIndex; } - (instancetype)initWithTestArray:(TestArray *)array { if (self = [super init]) { _array = array; _currentIndex = 0; } return self; } - (id)nextObject { if (_currentIndex &gt;= [self.array numberOfItems]) { return nil; } else { return array[_currentIndex++]; // 假设 TestArray 实现了 `objectAtIndexedSubscript:` 方法 } } // 这里还需要注意的是 NSEnumerator 会自动实现 `-allObjects` 方法，将 `-nextObject` 方法返回的对象填入数组中 @end @interface TestArray: NSObject - (NSEnumerator *)objectEnumerator; - (NSUInteger)numberOfItems; @end @implementation TestArray { std::vector&lt;NSNumber *&gt; _numberList; } - (NSUInteger)numberOfItems { return _numberList.size(); } - (NSEnumerator *)objectEnumerator { return [[TestEnumerator alloc] initWithTestArray:self]; } @end NSEnumerator 也是遵守 NSFastEnumeration 协议，所以可以还可以使用 for-in 循环来遍历 NSEnumerator 对象。 基于 block 的遍历 NSArray *array = @[@1, @2, @3]; [array enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop) { NSLog(@&quot;%@&quot;, object); }]; 这种遍历是现在经常使用的方式，而且这种方式还提供了很多有用的特性。 - (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block 上面这个方法就可以指定 NSEnumerationOptions 参数，可以反向遍历和并行遍历。同时系统会在这个方法的 block 里添加一个 autoreleasepool。 这里不太懂，苹果官方给出的例子也就是简单的实现了 enumerateObjectsUsingBlock: 方法。苹果官方例子：FastEnumerationSample. NSFastEnumeration NSArray *array = @[@1, @2, @3]; for (NSNumber *number in array) { NSLog(@&quot;%@&quot;, number); } 利用 for-in 遍历容器对象也是非常常见的遍历方法，并且这种方式也是最快的，要让自定义的对象支持这种遍历模式还是比较麻烦的。 支持这种遍历模式的对象需要遵守 NSFastEnumeration 协议，并实现方法： - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len; 接下来详细解释下这些参数的含义： state: 这是个 NSFastEnumerationState 的结构体，申明如下： typedef struct { // 在第一次调用 `countByEnumeratingWithState:objects:count:` 方法时，state 为 0， // 这个在遍历的时候用不到，可以用来存储额外信息 unsigned long state; // C 数组，`countByEnumeratingWithState:objects:count:` 方法调用者要去遍历的数组 id *itemsPtr; // 用来检测遍历期间数组是否被修改 unsigned long *mutationsPtr; // 存储额外信息 unsigned long extra[5]; } NSFastEnumerationState; stackbuf: countByEnumeratingWithState:objects:count: 方法调用者提供的数组，当我们数据结构是不连续的内存时，需要用到这个数组 len: stackbuf 数组的长度，当使用到 stackbuf 数组时，需要用到 len 来检测 实现 countByEnumeratingWithState:objects:count: 这个方法，还需要挺多要写的，打算另写一篇来说如何实现。 相关链接 Comparison of Objective-C Enumeration Techniques NSFast​Enumeration / NSEnumerator FastEnumerationSample ","link":"https://lzhenhong.github.io/post/shi-zi-ding-yi-de-lei-zhi-chi-ios-de-mei-ju-fang-shi/"},{"title":"2016 总结","content":"因为自己现在大四了，而且今年也发生了挺多的事情，第一次有想写总结的想法。所以就趁着 2016 年的尾巴来写一篇总结。 今年主要发生的事情就是： 找实习 暑假实习 找工作 大三下学期找实习 因为大三的暑假学校要求必须实习，是有学分的，然后自己几乎在大三下学期刚开学就开始不停的投简历找实习。 第一次电话面试是腾讯，因为是学长给内推的，所以三月份中旬就接到了电话面试的电话，是在两天之后，自己当时还是准备了一两天 iOS 的面试题，但是电面的时候一上来就让写快排，因为自己光准备 iOS 了，算法／数据结构之类根本没看，所以这题也就写个大概。然后还问很多关于计算机基础的知识点，例如：网络通信／操作系统／计算机组成／C 语言等。自己当时完全没有准备这些，所以自然而然就挂在电面上。 在腾讯之后就是网易的 iOS 实习生，自己在有了一定的准备之后，通过了网易的笔试，虽然笔试的题目比较基础，但是还是给了我一定的信心。通知我去面试，自己还闹出了一个比较大的笑话，这里就不说了。 在腾讯和网易没有着落之后，自己就开始广撒网，在招聘网站不停的投简历，不停的被拒绝。有一段时间甚至不想去准备了，想着直接跟着学校去实习，完成暑假实习这个任务算了。但是看着身边的人也一直在不停的准备，自己还是慢慢的坚持下来了。那段时间，一直在准备面试的事，也学到了很多知识。不停的看数据结构和 iOS 面试相关的博客。最后再经过一番折腾之后，拿到了下厨房的 iOS 实习 offer。 暑假三个月实习 在拿到下厨房的实习 offer 之后，自己还刻意准备了一些 iOS 相关的知识，例如：URL Loading System／Masonry 的使用等。 在 7 月 15 日到达北京，在酒店住了两三天，然后在公司附近找到了租房，于是就开始了为期三个月的实习。三个月的实习虽然短暂，但是这是我的第一份工作，还是在这份工作中学习到了许多有用的知识： 在公司中多人如何协同合作； 在 iOS 专业知识上同事也给予了我很大的帮助； 下厨房项目涉及到 iOS 的方方面面，也增长了自己的见识。 在实习期间，我还参加了百度的面试，虽然最后挂了 😭😭。但是在面试的过程中，还是让我认识到了自己的不足，以及对以后的人生没有明确的规划。在这次面试之后，自己也有思考以后的发展应该是怎样，在这里就不扯了。 总之，暑假的三个月实习还是让我收获很多，让我对以后的规划有了认真的思考。 大四上学期找工作 因为在北京实习，没有怎么参加学校的校招，就参加了百度的校招，还挂了，所以直到现在都还没有找到工作。现在也一直在不停的找工作，感觉回到了大三下学期。 最近一段时间，也接受了爱奇艺和携程的电面，感觉也并不怎样。归根结底，还是自己的水平太次。虽然最近一段时间，自己也一直不断的在学习，但还是差得很远。 近期，自己有了一个想法，不知道最后能不能实现，希望不要像以前一样半途而废。 在这一段时期，我主要还是着重于自己需要提高的地方： 算法／数据结构 iOS 专业知识 计算基础知识 Python 的学习 总结 不管怎样，人还是不要停下学习的脚步。前段时间看到过一句话，觉得很触动人心： 越努力的人，越幸运。 ","link":"https://lzhenhong.github.io/post/2016-zong-jie/"},{"title":"UIResponder 拾遗：inputView 和 inputAccessoryView","content":"前几天在看响应者链条的时候，看到 UIResponder 有两个很有用的属性，但是自己不熟悉，就是 inputView 和 inputAccessoryView。原来自己练手的时候，需要这样的功能，但是自己不知道这两个属性，导致自己花费了很多时间。所以，就写下这篇，算是对不知道的知识的补充。 UITextField 的 inputView 和 inputAccessoryView UITextField 的 inputView 默认情况下，当 UITextField 对象成为第一响应者的时候，系统会唤出系统键盘来接收用户的输入。 但是在有些时候，我们不希望唤出系统键盘，而是我们自定义的 view 来接收用户的输入，在这种情况下，inputView 就派上用场了。inputView 的作用就是让开发者提供自定义的 view 来获取用户的输入，当 UITextField 对象成为第一响应者的时候，系统会尝试唤出 inputView，如果 inputView 存在，就唤出开发者提供的 inputView；如果 inputView 不存在，也就是说这个属性的值是 nil（inputView 默认就是 nil），系统会唤出系统键盘。 现在假设当我们点击 UITextField 之后，显示出来的是一个 UIDatePicker。大概的实现代码： @interface ViewController () @property (nonatomic, weak) IBOutlet UITextField *textField; @property (nonatomic, strong) UIDatePicker *datePicker; @end @implementation ViewController - (UIDatePicker *)datePicker { if (!_datePicker) { _datePicker = [[UIDatePicker alloc] init]; _datePicker.datePickerMode = UIDatePickerModeCountDownTimer; } return _datePicker; } - (void)viewDidLoad { [super viewDidLoad]; self.textField.inputView = self.datePicker; } @end UITextField 的 inputAccessoryView 接下来说一下 inputAccessoryView 的作用，这个属性就是在 inputView 或者系统键盘上添加一个辅助的 view，例如下图高亮部分（图片截取自奇点）： 我们自己来添加一个 inputAccessoryView，大概的代码实现： @interface ViewController () @property (nonatomic, weak) IBOutlet UITextField *textField; @property (nonatomic, strong) UIToolbar *toolBar; @end @implementation ViewController - (UIToolbar *)toolBar { if (!_toolBar) { _toolBar = [[UIToolbar alloc] init]; _toolBar.bounds = (CGRect){CGPointZero, self.view.bounds.size.width, 49}; UIBarButtonItem *spaceItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:NULL]; UIBarButtonItem *rightItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(done)]; _toolBar.items = @[spaceItem, rightItem]; } return _toolBar; } - (void)viewDidLoad { [super viewDidLoad]; self.textField.inputAccessoryView = self.toolBar; } - (void)done { NSString *text = [NSString stringWithFormat:@&quot;%.2lf s&quot;, self.datePicker.countDownDuration]; if (self.textField.isFirstResponder) { self.textField.text = text; [self.textField resignFirstResponder]; } } @end UITextView 的自定义 inputView／inputAccessoryView 与 UITextField 类似。 UIReponder 的 inputView 和 inputAccessoryView UIReponder 的 inputView 我们看一下 inputView 和 inputAccessoryView 在 UIResponder 的声明： // Called and presented when object becomes first responder. Goes up the responder chain. @property (nullable, nonatomic, readonly, strong) __kindof UIView *inputView NS_AVAILABLE_IOS(3_2); @property (nullable, nonatomic, readonly, strong) __kindof UIView *inputAccessoryView NS_AVAILABLE_IOS(3_2); 这里我们看到 UIResponder 将这两个属性声明为 readonly，所以当我们使用例如：UIButton 的时候，我们就需要继承这些类，然后重新将这两个属性声明称 readwrite。 假设我们点击一个 button 时，要显示一个 UIDatePicker，大概的代码实现： @interface TSButton : UIButton @property (nonatomic, strong, readwrite, nullable) UIView *inputView; @property (nonatomic, strong, readwrite, nullable) UIView *inputAccessoryView; @end @implementation TSButton // 1 - (BOOL)canBecomeFirstResponder { return YES; } // 2 - (BOOL)canResignFirstResponder { return YES; } @end @interface ViewController () @property (nonatomic, weak) IBOutlet TSButton *showDatePickerButton; @property (nonatomic, strong) UIDatePicker *datePicker; @end @implementation ViewController - (UIDatePicker *)datePicker { if (!_datePicker) { _datePicker = [[UIDatePicker alloc] init]; _datePicker.datePickerMode = UIDatePickerModeCountDownTimer; } return _datePicker; } - (void)viewDidLoad { [super viewDidLoad]; self.showDatePickerButton.inputView = self.datePicker; } - (IBAction)showDatePicker { // 3 [self.showDatePickerButton becomeFirstResponder]; } @end 我们在这里要注意有注释的地方，除却 UITextField 和 UITextView 之外，因为这两个控件会自动成为第一响应者，其他的 UIResponder 子类想要成为第一响应者有两步要做： 覆写 canBecomeFirstResponder 并返回 YES； 主动调用 becomeFirstResponder 方法。 因为只有成为第一响应者，系统才会去唤出 inputView 与 inputAccessoryView，所以我们需要主动调用 becomeFirstResponder 方法。 reloadInputViews 用法 当对象是第一响应者时，调用这个方法来刷新 inputView 和 inputAccessoryView。这些 view 会立马被替换，没有动画。如果对象不是第一响应者，则这个方法就没有任何效果。 与 inputView 和 inputAccessoryView 相关的通知 我们有时会监听与系统键盘相关的通知，以便在系统键盘出现的时候，来调整我们的 UI 界面。同样，自定义的 inputView 出现或者消失时也会触发键盘相关的通知。我们同样可以监听 UIKeyboardWillShowNotification, UIKeyboardDidShowNotification, UIKeyboardWillHideNotification, 和 UIKeyboardDidHideNotification 通知来调整 UI 视图。这里需要注意的是，当有 inputAccessoryView 时，通知的 userInfo 中的高度数据，是 inputView 的高度加上 inputAccessoryView 的高度。 最后 在 UIResponder 还有 inputViewController 和 inputAccessoryViewController 属性，这两个属性跟自定义键盘有关。下面是它们在 UIResponder 中的声明： // For viewController equivalents of -inputView and -inputAccessoryView // Called and presented when object becomes first responder. Goes up the responder chain. @property (nullable, nonatomic, readonly, strong) UIInputViewController *inputViewController NS_AVAILABLE_IOS(8_0); @property (nullable, nonatomic, readonly, strong) UIInputViewController *inputAccessoryViewController NS_AVAILABLE_IOS(8_0); 相关链接 Custom Views for Data Input The Responder Chain Is Made Up of Responder Objects ","link":"https://lzhenhong.github.io/post/uiresponder-shi-yi-inputview-he-inputaccessoryview/"},{"title":"iOS 的响应者链条 ⛓️","content":"响应者链条在刚学 iOS 的时候有学过，但是平常开发也很少去仔细思考，也没有发生过很大的错误，所以就更加不会去考虑 What Under The Hood。 在实习的时候要做自定义 transition。我在 UITransitionView 上添加了一个 subview 作为背景 view，点击这个背景的 view，要 dismiss 掉 present 的 ViewController，给背景的 view 添加了一个 UITapGestureRecognizer，但是背景的 view 就是死活不响应点击。来来回回折腾了好久才找出原因：事件根本就没有传递给背景的 view 😭😭。 哎！还是基础不扎实的锅！！！就写下这篇来记录踩的坑。 响应者对象 当用户点击应用的控件时，硬件检测到物理接触并通知操作系统，UIKit 会创建相应的 UIEvent 对象，并将事件对象传递给正在运行的应用的事件队列。对于触摸事件，这个对象就是包含一系列 UITouch 对象的 UIEvent 对象。 我们需要处理这些事件，来给用户正确的反馈。在 iOS 中，继承自 UIResponder 的对象，都可以作为响应者链条上的节点来响应事件。UIResponder 定义了一系列接口来处理事件响应，UIView／UIViewController／UIApplication 都是继承自 UIResponder 类。这里注意 Core Animation 的 Layer 不是响应者对象，CALayer 是直接继承自 NSObject。 UIResponder 的继承层级关系： 确定 hit-testing view 既然知道 iOS 中有许多对象可以响应事件，我们就需要确定哪一个响应者对象是最适合处理一个事件对象。对于触摸事件来说，系统会首先将触摸事件分发给触摸事件发生的视图来确认这个视图是否能处理这个事件对象，这个视图称为 hit-test view。 寻找 hit-test view 的过程称为 hit-testing，这个过程会确定触摸事件发生的位置是否处于相关视图的边界内。如果在的话，就递归检测子视图。视图层级中包含触摸事件发生位置的最低层级的视图就是 hit-testing view。确认 hit-testing view 之后，UIKit 就会将事件传递给 hit-testing view，让 hit-testing view 来尝试处理这个事件。 我们通过一个示例来演示 hit-testing 的过程。下图是 Apple 官方的例子： 假设用户点击了视图 E，系统按照以下顺序来查找 hit-test view： 点击事件发生在视图 A 的边界内，所以检测子视图 B 和 C； 点击事件不在视图 B 的边界内，但在视图 C 的边界范围内，所以检测子视图 D 和 E； 点击事件不在视图 D 的边界内，但在视图 E 的边界范围内。 视图 E 是包含触摸点的视图层次架构中最底层的视图，所以它就是 hit-test view。 在 hit-testing 过程中，会调用 hitTest:withEvent: 方法，并传入 CGPoint 和 UIEvent 对象。这个 hitTest:withEvent: 方法先要调用 pointInside:withEvent: 方法。如果 pointInside:withEvent: 返回 YES，那么就会递归子视图的 hitTest:withEvent: 方法来进一步确定 hit-testing view。 如果方法 pointInside:withEvent: 返回 NO，那么这个 view 的整个分支都会被忽略。这就意味着超出父视图的子视图的范围，是没有办法接收到触摸事件。 响应者链条 在触摸事件下，UIApplication 对象最先从事件队列中取出最前面的事件，然后将其分发给 key window，随后 key window 将事件传递到 hit-testing view，让 hit-testing view 有第一机会来处理这个触摸事件，如果这个 hit-testing view 不能处理这个触摸事件，hit-testing view 就会将这个触摸事件沿着响应者链条传递，直到找到能处理这个触摸事件的响应者或者被丢弃。 响应者链条的构成与 App 的视图层级有密切的关系，所以，在 App 视图层级结构构建起来的同时，响应者链条也逐渐构建完成。 我们接下来看两个 Apple 官方的例子，如下图所示： 我们来分析一下右边的视图就可以了： initial view 尝试处理触摸事件。如果它不能处理这个事件，它就传递给 superView，这个 superView 就是 initial view 的 nextResponder。 superView 尝试处理触摸事件。如果不能的话，就传递给管理这个 view 的 UIViewController，因为这个 view 是 UIViewController 的 top most view。 UIViewController 对象会尝试处理这个触摸事件。如果不能，UIViewController 就会将这个事件传递给自己 top most view 的 superView。 这个 top most view 尝试处理这个触摸事件。如果不能，因为这个 view 也是 UIViewController 的 top most view，它就会将事件传递给 UIViewController。 UIViewController 对象尝试处理触摸事件。如果不能，它会将事件传递给 key window，因为这个 key window 的 rootViewController 是这个 UIViewController 对象。 key window 尝试处理触摸事件。如果不能，它会将事件传递给 UIApplication 对象。 UIApplication 对象尝试处理事件。如果不能，事件就被丢弃。 总结 在实际开发中，我们会碰到响应者对象不能响应事件时，可以先从一下几点排除： 先看响应者对象下面的属性是否设置正确： userInteractionEnabled != NO hidden != YES alpha != 0.0 ~ 0.01 UIImageView 的 userInteractionEnabled 默认是 NO，UIImageView 默认是不能接收事件，因此其子控件也不能接收触摸事件。 如果到了这一步就好好分析一下响应者链条吧。 这里仅仅介绍了如何寻找 hit-testing view 和响应者链条的构建。更多关于 UIResponder 的分析可以看 UIKit: UIResponder | 南峰子的技术博客 或者 UIResponder Class Reference。 相关链接 深入浅出 iOS 事件机制 UIKit: UIResponder | 南峰子的技术博客 Event Delivery: The Responder Chain UIResponder Class Reference iOS Events and Responder Chain ","link":"https://lzhenhong.github.io/post/ios-de-xiang-ying-zhe-lian-tiao/"},{"title":"App Programming Guide for iOS - Background Execution","content":"我们知道 iOS App 有五种状态：not running／inactive／active／background／suspended，当用户按下 Home 键的时候，App 就会进入 background 状态，随后进入 suspended 状态。在 suspended 状态下，我们没有办法对 App 进行任何操作。所以，我们会尽量在 background 状态下就做好 App 的一些清理等操作，来使 App 有进入 suspended 的准备。但是，iOS 系统分配给 App 的 background 状态下的时间是有限的，我们需要做一些自定义的操作来向 iOS 系统申请更多的后台时间，或者直接常驻后台。例如一些音乐类 App，当我们退出这类 App，我们还是可以听到 🎵 的播放，这些 App 就属于常驻后台的 App。 iOS 为三类适合在后台运行的 App 提供很好的支持，这三类 App 分别是： App 在前台的时候开启了一个持续时间较短的任务，当 App 进入后台的时候希望能继续执行完成。 App 在前台初始化一个下载操作，当 App 进入后台时，将下载操作的控制权交给系统。这样 App 就能在下载操作继续的情况下被挂起或者结束。 支持特定的在后台执行任务的 App 要先声明它们支持的一个或者多个后台运行模式。 Executing Finite-Length Tasks 当 App 进入到 background 状态，系统期望尽快将 App 转入 suspended 状态。但是如果这个时候 App 还需要更多时间来做一些操作，我们就需要向系统申请额外的后台运行时间。iOS 为 UIApplication 对象提供了 beginBackgroundTaskWithName:expirationHandler: 和 beginBackgroundTaskWithExpirationHandler: 方法来申请额外的后台时间，调用任意一个方法都会延缓 App 进入 suspended 状态，当任务完成之后，你需要调用 UIApplication 对象的 endBackgroundTask: 方法来告诉系统，你的 App 已经准备好可以进入 suspended 状态。 需要注意的是， beginBackgroundTaskWithName:expirationHandler: 和 beginBackgroundTaskWithExpirationHandler: 这两个方法的调用都会为相应的后台 task 创建唯一的 token，这个 token 是 endBackgroundTask: 需要的参数，如果调用 endBackgroundTask: 失败会导致 App 直接被终止。我们在申请额外后台时间的时候，可以提供一个 expirationHandler，当额外时间消耗完，task 这时还是没有完成的话，系统就会调用这个 handler 来给你最后的机会做一些清理操作。 你不需要等到 App 进入后台状态才去调用 beginBackgroundTaskWithName:expirationHandler: 或者 beginBackgroundTaskWithExpirationHandler: 方法，你可以在开始一个 task 之前就可以调用这两个方法中的任意一个，然后在 task 完成之后尽快调用 endBackgroundTask:。当 App 还在前台的时候就可以这样做。 Starting a background task at quit time @property (nonatomic, assign) UIBackgroundTaskIdentifier bgTask; - (void)applicationDidEnterBackground:(UIApplication *)application { bgTask = [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^{ // App 已经快要没有后台运行时间 // 在这里尽快清理没有完成的 task [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; }]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 做一些操作来完成 task [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; }); } 在原来经常用这种方式来处理一些网络上传和下载操作，系统通常情况下会给大概 10 mins 的时间，但是系统并不保证一定会给 10 mins，实际的后台运行时间是由 iOS 系统决定的，可以通过 backgroundTimeRemaining 来查看剩余的后台运行时间。现在可以用 NSURLSession 来处理网络请求，即使 App 进入 suspended 状态 NSURLSession 还是可以继续运行。More about NSURLSession: NSURLSession Tutorial: Getting Started. 严格来说这个并不算后台模式，因为它只是申请一些额外的后台运行时间，并不能常驻后台，最后还是要进入 suspended 状态。 Downloading Content in the Background 前面提到过，下载网络数据使用 NSURLSession，可以在 App 被挂起或者停止的时候将控制权交给系统。 为了支持后台下载，你需要为 NSURLSession 做一些配置。 用 NSURLSessionConfiguration 的 backgroundSessionConfigurationWithIdentifier: 方法来创建一个 NSURLSession 的配置对象。 设置 NSURLSessionConfiguration 对象的 sessionSendsLaunchEvents 属性为 YES。 如果 App 在前台开始这个请求，最好将 NSURLSessionConfiguration 对象的 discretionary 属性也设置为 YES。 正确设置 NSURLSessionConfiguration 对象的其他属性。 用创建好的 NSURLSessionConfiguration 对象来创建 NSURLSession 对象。 用这个配置好的 NSURLSession 创建的上传 &amp; 下载操作都可以在恰当的时机将控制权交给系统。对于所有后台上传 &amp; 下载的 task，你必须要提供一个遵守 NSURLSessionDownloadDelegate 协议的 delegate，如果你不需要 delegate 提供的额外特性，在创建 session 对象的时候给 delegate 参数传递 nil (session 对象在 App 退出或者你使 session 对象无效之前会对 delegate 有一个强应用)。 当 task 完成之后，如果 App 在运行，不管是前台还是后台，都会通知 session 对象的 delegate。如果 task 还没有完成，这时系统结束 App，系统还会继续在后台管理 tasks，当 session 相关的 tasks 都完成之后，系统会重新唤醒 App 并调用 application:handleEventsForBackgroundURLSession:completionHandler: 方法。如果是用户主动结束 App，系统会取消等待执行的 tasks，不会继续在后台管理 session 相关的 tasks。 在 Stack Overflow 找了几篇关于用户主动退出 App，后台下载操作是否会继续执行的讨论，感兴趣的话可以看一下：第一篇／第二篇／第三篇。 Implementing Long-Running Tasks 一些特定类型的 App 需要一直运行在前台或者后台，不进入 suspended 状态，这种类型 App 需要向系统申请后台运行权限，可以在项目 setting 的 Capabilities 选项的来声明特定类型的后台应用。只有特定的几种允许常驻后台： 需要一直得到用户位置更新信息的 App。 播放音频或者记录音频的 App。 定时下载和处理数据的 App。 支持 Voice over Internet Protocol (VoIP) 的 App。 接收外设更新的 App。 Tracking the User’s Location 在后台跟踪用户的位置有好几种方法，大部分都不需要 App 一直运行在后台： 用户的位置信息有显著的更新才通知 App，当 App 不需要特别精确的位置信息，Apple 强烈推荐使用这种方法。 只在前台获取用户的位置信息。 后台获取用户位置。 当 App 使用第一种服务，有显著的位置信息更新时，如果 App 处于 suspended 状态，系统会将 App 变成 background 状态以便来处理位置信息的更新。如果 App 使用这种位置服务的时候，被系统完全退出，当有位置信息更新时系统就会启动 App 来处理，并调用 CLLocationManager delegate 的 locationManager:didUpdateLocations: 方法。 前台或者后台位置服务都是使用标准的 Core Location 服务来取得位置数据。不同的是，使用前台服务的 App 在应用被挂起之后就不会再接收到位置信息更新。 当你在 Xcode 项目的 Capabilities 选项中勾选了 Location Update，这样做并不会阻止 App 进入 suspended 状态，而是在位置信息更新的时候唤醒 App 来处理位置数据。 对Map 方面了解比较少。More about location services: Location and Maps Programming Guide. Playing and Recording Background Audio 这类 App 可以在后台播放或者记录音频，但是 App 播放的音频必须是有声的。因为以前有些 App 会通过播放一段没有声音的音频来获取后台运行权限。 典型的音频类 App 包括： 音乐播放 App。 记录音频 App。 支持 AirPlay 播放音频 &amp; 视频的 App。 VoIP App。 当你将 App 声明为这类应用，系统的 media frameworks 会自动阻止你的 App 进入 suspended 状态。因为 App 一直处理后台，这时处理回调和在前台没有区别，但是在回调中你应该只处理播放相关的数据，并且尽可能快的返回。当播放或者记录停止，系统就会让 App 进入 suspended 状态。 可能会有多个 App 属于音频类型，系统会决定这些 App 的优先级。前台的 App 的优先级适中比后台高。在后台同时播放音频是有可能的，这要取决于每个 App 的 audio session 对象的配置。你应该要时刻准备好音频播放被打断的打算，并且提供相应的操作来处理打断和一些其他音频相关的通知。More about configuring audio session objects for background execution: Audio Session Programming Guide. Background Fetch 这类 App 需要时不时的检查是否有新数据，并且在有新数据的时候初始化下载操作来下载新内容。当你在 Xcode 中将 App 声明成这类应用并不能保证系统会给 App 分配时间来执行 background fetch。系统会决定在恰当的时候来执行 background fetch。 当有好机会的时候，系统会唤醒或者启动 App 到 background 状态，然后调用 UIApplication 代理的 application:performFetchWithCompletionHandler: 方法，在这个方法中来检查是否有新内容需要下载。当你完成新内容的下载之后，要尽快调用提供的 completion handler 块，并且传递参数来表明是否有新数据，如果传递的是 UIBackgroundFetchResultNewData 可能会让 iOS 对应用做一次截图操作。执行这个 block 会告诉系统可以将 App 变成 suspended 状态了。 Implementing a VoIP App VoIP 应用可以让用户使用网络连接来通话，而不是使用蜂窝服务。这样的 App 需要维护与服务器维护一个长连接。iOS 系统不会让 VoIP 应用一直保持运行，而是提供工具来监测 sockets，并且会在需要的时候唤醒 VoIP 应用，并将 socket 的控制权交给 VoIP 应用。 More about VoIP: iOS VoIP (VoIP Push)开发集成 &amp; iOS Call Kit for VoIP &amp; Tips for Developing a VoIP App. Using Push Notifications to Initiate a Download 当服务器发送远程通知来告诉 App 有新内容，你可以告诉系统在后台运行你的应用来开始下载新内容。 为了触发这样的操作，服务器发出的 notification payload 中一定要有 content-available 字段，并且设置为 1。当这样的字段出现，系统会唤醒或者启动 App 到 background 状态，并且调用相应的代理方法来让你做一些操作。 Communicating with External Accessory 对这一块真的没有一点接触，所以我就不瞎说了 😛😛。给出官方文档。 Downloading Newsstand Content in the Background 现在好像已经看不到这种应用，记得在 iOS 7 的时候还下过一个。感兴趣可以看一下官方文档。 Being a Responsible Background App Do not make any OpenGL ES calls from your code. Cancel any Bonjour-related services before being suspended. Be prepared to handle connection failures in your network-based sockets. Save your app state before moving to the background. Remove strong references to unneeded objects when moving to the background. Stop using shared system resources before being suspended. Avoid updating your windows and views. Respond to connect and disconnect notifications for external accessories. Clean up resources for active alerts when moving to the background. Remove sensitive information from views before moving to the background. Do minimal work while running in the background. More details. Opting Out of Background Execution 如果你一点也不想 App 运行在 background 状态下，你可以在 Info.plist 文件中添加 UIApplicationExitsOnSuspend 键并且设置为 YES，这样 App 只有 not running／inactive／active 状态。当用户按了 Home 键之后，applicationWillTerminate: 方法就会调用。Apple 不推荐这样实现。 Summary 废话了很多，我自己看到这里都很辛苦了 😅😅。这里有一篇知乎的 所谓的iOS「伪多任务」和Android的多任务处理的区别在哪？感兴趣的话可以看一下。 Apple 官方文档还有一节关于 Understanding When Your App Gets Launched into the Background。同样，感兴趣的话可以看一下。 还有关于 Background Execution 的实践，可以看 Background Modes Tutorial: Getting Started. Related Link Background Execution Background Modes Tutorial: Getting Started ","link":"https://lzhenhong.github.io/post/app-programming-guide-for-ios-background-execution/"},{"title":"UIScrollView And Autolayout","content":"这一篇介绍如何将 Autolayout 应用到 UIScrollView 上。 在 UIScrollView Tutorial: Getting Started 这篇文章中的 Scrolling and Zooming a Large Image 这节中，给 UIScrollView 添加 top／bottom／leading／trailing 的约束，确定 UIScrollView 的 frame。再给 UIScrollView 中的 UIImageView 添加 constant 为 0 的 top／bottom／leading／trailing 约束，运行之后，UIScrollView 中的 contentSize 就是图片的大小，可以滚动查看所有内容。 添加的约束如下图。 看到这里比较好奇 UIScrollView 是如何使用 Autolayout 来自动计算 contentSize 的。所以去网上搜了一下相关资料，加上一些自己的理解整理出来这篇文章。 Key Point UIScrollView 使用 Autolayout 主要是用来自动确定自身的 frame 与 contentSize，frame 是根据 UIScrollView 自己的约束来确定，而 contentSize 是根据子视图与 UIScrollView 之间的约束来确定的。所以，UIScrollView 的子视图添加的约束一定要能确定 UIScrollView 的 contentSize。 这点跟 self-sizing cell 有点相似，cell 可以根据完整的内部约束来确定自己的高度，只是 cell 的宽度与 UITableView 的宽度是相同的，所以我们不需要显示地去表明子视图具体的宽度，只需要确定 leading 和 trailing 的约束就可以确定子视图的 width，再添加好垂直方向上的约束，系统就可以根据我们添加的约束自动算出 cell 的高度。 The trick to getting Auto Layout to work on a UITableViewCell is to ensure you have constraints to pin each subview on all sides - that is, each subview should have leading, top, trailing and bottom constraints. 上面这段来自 Self-sizing Table View Cells。表示 cell 自动算高度需要的约束条件，感兴趣的话可以了解一下。 In Depth Explanation 一般来说，Autolayout 认为视图的 top／bottom／leading／trailing 边界是可见 (我的理解是这里的可见相对于 UIScrollView 的 content view 的边界而言的，因为这个 content view 是不可见的) 的边界。也就是说，如果你把一个视图固定在 superview 的左边界，你其实是把视图固定在 superview 的 bounds 的最小 x 值。改变 superview 的 bounds 的 origin 值不会改变视图的位置。 UIScrollView 通过改变 bounds 的 origin 值来滚动它的内容。为了让 UIScrollView 能与 Autolayout 协同工作，UIScrollView 的 top／bottom／leading／trailing 边界代表 UIScrollView 的 content view 的边界。 Position and size your scroll view with constraints external to the scroll view. Use constraints to lay out the subviews within the scroll view, being sure that the constraints tie to all four edges of the scroll view and do not rely on the scroll view to get their size. 上面两点来自 UIScrollView And Autolayout。解释起来就是 UIScrollView 需要自己来确定自身的大小和位置，不能依靠子视图的约束。UIScrollView 的子视图需要自己明确自己的大小，不能依赖 UIScrollView 来决定大小。 拿我在最前面提到的例子来解释一下： 我们先给 UIScrollView 添加 top／bottom／leading／trailing 的约束，这样就可以确定 UIScrollView 自身的 frame。这里没有用到子视图的信息来确定 frame。 我们添加 UIImageView 到 UIScrollView 中，然后给 UIImageView 设置图片内容。 给 UIImageView 添加 top／bottom／leading／trailing 的 constant 为 0 的约束。确定 UIScrollView 的 contentSize。 这样就👌👌了，UIImageView 有一个固有内容大小，默认与图片的大小相等，所以这里我们不需要明确指出 UIImageView 的宽高，只需要添加与 UIScrollView 边界的间距来确定 contentSize 的大小。 如果这里我们添加的是 UIView 的话，就需要添加 width／height 的约束来明确指出 UIView 的大小，例如：添加 width=50，height=50 的约束来指明 UIView 大小，然后再添加与 UIScrollView 的约束。我们可以这样理解：添加在 UIScrollView 自身的约束，是作用在 UIScrollView 可见的边界上。子视图与 UIScrollView 之间的约束中，是作用于子视图与不可见的 content view 上，而这个 content view 的大小是不确定的，需要根据子视图之间的约束来得出。 For Example 这跟我们平常使用 Autolayout 有点不太一样。下面举例来说明 Autolayout 在 UIScrollView 上使用的不同。 Use Autolayout in Common View (红色 view 是 UIView) 大概的代码实现，数值是我随便给的，运行结果不一定和上面一样。 self.view.backgroundColor = [UIColor blueColor]; UIView *redView = [[UIView alloc] init]; redView.backgroundColor = [UIColor redColor]; [self.view addSubview:redView]; [redView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(100, 50, 100, 50)); }]; UIView *yellowView = [[UIView alloc] init]; yellowView.backgroundColor = [UIColor yellowColor]; [redView addSubview:yellowView]; [yellowView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(redView).insets(UIEdgeInsetsMake(200, 50, 20, 20)); }]; 如果我们需要确定黄色 view 的 frame，添加如上的约束就可以得到。这是我们平常使用 Autolayout 添加的约束，如果视图可以根据自身内容得出固有内容大小，例如：UILabel／UIButton／UIImageView 等，那么只需要确定视图的位置就 👌。 Autolayout in UIScrollView self.view.backgroundColor = [UIColor blueColor]; self.scrollView = [[UIScrollView alloc] init]; self.scrollView.bounces = NO; self.scrollView.clipsToBounds = NO; self.scrollView.backgroundColor = [UIColor redColor]; [self.view addSubview:self.scrollView]; [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(100, 50, 100, 50)); }]; UIView *yellowView = [[UIView alloc] init]; yellowView.backgroundColor = [UIColor yellowColor]; [self.scrollView addSubview:yellowView]; [yellowView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.scrollView).offset(200); make.bottom.equalTo(self.scrollView).offset(-200); make.leading.equalTo(self.scrollView).offset(50); make.trailing.equalTo(self.scrollView).offset(-200); // Important make.width.and.height.equalTo(@100); }]; (红色的 view 是 UIScrollView) 这是上面代码的运行结果，我把 scrollView 的 clipsToBounds 设置为 NO，方便我们查看。如果我们不添加 make.width.and.height.equalTo(@100); 这行代码的话，黄色 view 是不会出现的，因为 scrollView 的 contentSize 不确定。 我们结合下面这张图来分析一下。(红色的 view 是 UIScrollView) 黑色边框代表 scrollView 的 contentSize ，我们不能假设这个值是已知的，这个是未知量，需要我们给出完整的约束来计算。所以，contentSize 不知道，不用黑色约束的话，就无法得出黄色 view 的大小，黄色 view 就不显示。 Summary UIScrollView 的子视图需要自己明确自己的大小，不能依赖 UIScrollView 来决定大小。UIScrollView 是需要依靠子视图的约束来确定 contentSize 的，所以在 UIScrollView 上使用 Autolayout 需要注意子视图的约束是否足够完整来确定 contentSize。 UIScrollView 与同级视图或者父视图之间的约束只能确定 UIScrollView 的 frame，不能确定 contentSize。 Related Link UIScrollView And Autolayout UIScrollView Tutorial: Getting Started 史上最简单的UIScrollView+Autolayout出坑指南 UIScrollview与Autolayout的那点事 AutoLayout Tips ","link":"https://lzhenhong.github.io/post/uiscrollview-and-autolayout/"},{"title":"百度面试准备","content":"申明：以下知识点均来自网络，来源均在每节最前面给出，侵删。 感谢愿意分享知识的人 🙏🙏，是他们让我们学习了更多更好的知识。 前一段时间准备百度面试总结的一些知识点，虽然面试没过 😭😭 把这些东西记录下来，也方便自己以后查看。 + load 方法理解 你真的了解 load 方法么？ 「Effective Objective-C」Page 200 文章介绍的很详细，推荐阅读，但对面试来说，我们需要知道下面的知识应该差不多了。同时 Effective Objective-C 这本书的第 51 条也介绍了 + load 方法。 load 作为 Objective-C 中的一个方法，与其它方法有很大的不同。它只是一个在整个文件被加载到运行时，在 main 函数调用之前被 ObjC 运行时调用的钩子方法。其中关键字有这么几个： 文件刚加载 main 函数之前 钩子方法 由于它的调用不是惰性的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 load 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖。 load 方法并不像普通的方法那样，它并不遵从那套继承规则。如果某个类本身没实现 load 方法，那么不管其各级超类是否实现此方法，系统都不会调用。 load 方法调用顺序： 父类先于子类调用 类先于分类调用 不要在 load 方法中使用其他类，因为类的载入我们是不能确定的，所以会造成安全隐患。 load 方法务必实现得精简一些，也就是要尽量减少其所执行的操作，因为整个应用程序在执行 load 方法时都会阻塞。如果 load 方法中包含繁杂的代码，那么应用程序在执行期间就会变得无响应。不要在里面等待锁，也不要调用可能会加锁的方法。 其真正用途仅在于调试程序，比如可以在分类里编写此方法，用来判断该分类是否已经正确加载。 由于 + load 方法的特殊性，我们经常会在 + load 方法中进行 Method Swizzling 。 + initialize 方法理解 懒惰的 initialize 方法 「Effective Objective-C」Page 202 + initialize 只会在对应类的方法第一次被调用时，才会调用。如果这个类一直没有使用，这个方法就不会执行。 + initialize 方法是在 alloc 方法之前执行完的，alloc 的调用导致了前者的执行。 在这个方法中，运行期系统是处于正常的状态，因此可以在此方法中调用任何类中的任意方法。 + initialize 方法只应该用来设置内部数据。不应该调用其他方法。若某个全局状态无法在编译期初始化，可以放在 + initialize 方法中来做。 // EOCClass.h #import &lt;Foundation/Foundation.h&gt; @interface EOCClass: NSObject @end // EOCClass.m static const int kInterval = 10; // 创建实例之前必须先激活运行期系统 static NSMutableArray *kSomeObjects; @implementation + (void)initialize { if (self == [EOCClass class]) { kSomeObjects = [NSMutableArray array]; } } @end + initialize 的调用是惰性的，它会在第一次调用当前类的方法时被调用 与 load 不同，+ initialize 方法调用时，所有的类都已经加载到了内存中 + initialize 的运行是线程安全的 子类会继承父类的 + initialize 方法，父类的调用先于子类。 runtime 理解 Method Swizzling Associated Objects 关联对象 AssociatedObject 完全解析 轻松学习之一－－Objective-C消息转发 Objective-C Runtime Method Swizzling Method swizzling 用于改变一个已经存在的 selector 的实现。这项技术使得在运行时通过改变 selector 在类的消息分发列表中的映射从而改变方法的掉用成为可能。 swizzling 应该只在 dispatch_once 中完成 由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。 实现的代码可以参考 Method Swizzling 。 Associated Objects 在分类中 @property 并不会自动生成实例变量以及存取方法，所以一般使用关联对象为已经存在的类添加「属性」。 我们使用了两个方法 objc_getAssociatedObject 以及 objc_setAssociatedObject 来模拟「属性」的存取方法，而使用关联对象模拟实例变量。使用 @selector(categoryProperty) (即 _cmd) 作为 key 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性。 在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量），所以我们需要使用关联对象以及两个方法来模拟构成属性的三个要素。 函数 objc_removeAssociatedObjects 的主要目的是在「初始状态」时方便地返回一个对象。你不应该用这个函数来删除对象的属性，因为可能会导致其他客户对其添加的属性也被移除了。规范的方法是：调用 objc_setAssociatedObject 方法并传入一个 nil 值来清除一个关联。可以看这里。 关联对象应用实例：动态修改UINavigationBar的背景色。 不懂待填：创建一个用于 KVO 的关联观察者 消息转发 读一下这一篇文章轻松学习之一－－Objective-C消息转发，简单易懂。 很多情况下，程序会在运行时挂掉并抛出 unrecognized selector sent to … 的异常。但在异常抛出前，Objective-C 的运行时会给你三次拯救程序的机会： Method resolution + (BOOL)resolveInstanceMethod:(SEL)sel + (BOOL)resolveClassMethod:(SEL)sel Fast forwarding - (id)forwardingTargetForSelector:(SEL)aSelector Normal forwarding - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector：如果 -methodSignatureForSelector: 返回 nil ，runtime 则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了 - (void)forwardInvocation:(NSInvocation *)anInvocation Objective-C 中给一个对象发送消息会经过以下几个步骤： 在对象类的 dispatch table 中尝试找到该消息。如果找到了，跳到相应的函数IMP去执行实现代码； 如果没有找到，runtime 会发送 + resolveInstanceMethod: 或者 + resolveClassMethod: 尝试去 resolve 这个消息； 如果 resolve 方法返回 NO，runtime 就发送 - forwardingTargetForSelector: 允许你把这个消息转发给另一个对象； 如果没有新的目标对象返回， runtime 就会发送 - methodSignatureForSelector: 和 - forwardInvocation: 消息。你可以发送 - invokeWithTarget: 消息来手动转发消息或者发送 - doesNotRecognizeSelector: 抛出异常。 Category 深入理解Objective-C：Category objc category的秘密 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处： 可以减少单个文件的体积 可以把不同的功能组织到不同的 category 里 可以由多个开发者共同完成一个类 可以按需加载想要的category 声明私有方法 模拟多继承 把 framework 的私有方法公开 extension 在编译期决议，它就是类的一部分，在编译期和头文件里的 @interface 以及实现文件里的 @implementation 一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension 一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加 extension，所以你无法为系统的类比如 NSString 添加 extension。 但是 category 则完全不一样，它是在运行期决议的。 就 category 和 extension 的区别来看，我们可以推导出一个明显的事实，extension 可以添加实例变量，而 category 是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。 怎么调用到原来类中被 category 覆盖掉的方法？ 对于这个问题，我们已经知道 category 其实并不是完全替换掉原来类的同名方法，只是 category 在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法。 iOS 内存管理 理解 iOS 的内存管理 弱引用的实现原理 弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： 我们在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型。 UIWindow 分析UIWindow UIWindow - Apple Developer View Programming Guide for iOS UIWindow 一旦被创建就会被添加到整个界面上。Xcode 创建的新项目使用 Storyboard，Storyboard 需要使用 AppDelegate 提供的 window 对象，Xcode 创建的模版自动提供该 window。Window 不展示自身，通常保留 rootViewController 的 view。不使用 Storyboard 的项目需要手动创建 UIWindow 对象，让 AppDelegate 引用这个对象，并调用 -makeKeyAndVisible 设成 app 的 keyWindow。 每一个 controller 都会被 UIWindow 接管，UIWindow 一次只能接管一个 controller。 UIWindow 会在一个 controller 的 - viewDidAppear 方法中才接管了当前 controller，而不是在- viewDidLoad 方法中。 UIWindow 有着比一切 controller 都要高的优先级显示权利，加载在 UIWindow 上面的 View 是不会被遮挡住的。keyWindow 是指定的用来接收键盘以及非触摸类的消息，而且程序中每一个时刻只能有一个 window 是 keyWindow。 UIWindow的主要功能： 提供一个区域来显示 views 发送 events 给 views ","link":"https://lzhenhong.github.io/post/bai-du-mian-shi-zhun-bei/"},{"title":"App Programming Guide for iOS - The App Life Cycle","content":"The Main Function 每个基于 C 语言的程序的入口都是 main 函数，iOS App 也没有区别。开发 iOS 你不需要自己编写 main 函数，Xcode 的模版项目会自动实现，一般情况下你不需要修改 main 函数。main 函数会将控制权交给 UIKit framework。UIApplicationMain 函数会创建应用的核心对象，从 SB 文件中加载 UI 界面，启动 App 的 runloop 等等。 #import &quot;AppDelegate.h&quot; int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } } 关于在 Main 函数之前发生了什么，可以看这个 iOS 程序 main 函数之前发生了什么。 The Structure of an App 每个应用的核心就是 UIApplication 对象，这个对象的任务就是处理系统与 App 之间的交互。 下面这张图片显示了大部分应用的对象以及这些对象扮演的角色。 在上面这张图中我们可以看到 iOS 应用遵守 MVC 架构。但是 MVC 是有一定的缺陷的，各种逻辑都是由 C(控制器) 来处理的，例如作为 V(视图) 的代理，接收 M(模型) 分发的通知，这样随着业务的增长，控制器中的代码就可能会越来越多。MVVM 等其他的设计模式就这样出现了。扯远了 🙄🙄 Object Description UIApplication 对象 UIApplication 对象管理 event loop 和 high-level 应用行为。当应用的状态发生变化或者有远程通知的时候，UIApplication 对象会通知它的 delegate 对象，这个代理对象就是你在 UIApplicationMain 函数中传递的最后一个参数。 App 的代理对象 这个对象用来处理 App 的状态变化，例如：Active -&gt; Background，还可以处理其他 App 级别的事件。每个 App 只有一个这样的代理对象。 数据模型对象 App 中的数据模型。For more see Document-Based App Programming Guide for iOS. 控制器对象 控制器对象是管理展示在屏幕上的内容，一个控制器对象管理一个 view 和其所有 subview。当需要展示的时候，控制器会将 view 添加到 App 的 window 上。 UIWindow 对象 UIWindow 对象协调多个 view 的展示。一般情况下，一个 App 只有一个 window 对象，但是 App 在外接设备上展示内容就会有多个 window。 UI (Views, Controls, Layers) 对象 Views 和 Controls 在特定的矩形框中展示可视化界面和处理这个区域内的事件。其实 Layer 才是真正渲染界面的对象，UIView 只是 CALayer 的代理，你可以直接创建 CALayer 对象，将其添加到视图层级中。 The Main Run Loop App 的 main run loop 处理所有与用户有关的事件，main run loop 运行在 App 的主线程上，这样保证 App 处理的事件与接收的顺序是一样的。 上面这张图向我们展示了 App 是如何处理用户交互的。当用户与设备进行交互的时候，系统会为这些交互生成相应的事件，然后通过 UIKit 的特殊端口传递给 App。事件在内部是通过队列管理的，事件是一个一个交给 main run loop 来处理的。UIApplication 对象是第一个接收到事件的，由它来决定如何处理这个事件。 一些类型的事件是通过 main run loop 分发的，另外一些事件是直接分发给 delegate 或者传递给 block。分别举一些例子 Controls 的触摸事件跟 Views 的触摸事件是不一样的，Controls 的交互方式通常来说是有限的，所以这些事件被重新打包成动作消息 (action messages) 传递给 target 对象。这里就是 target-action 设计模式。 Execution States for Apps App 有五种状态，在特定的时间，你的 App 会处于任意一种状态，这五种状态分别是： Not running：App 没有启动 Inactive：App 在前台，但是没有处理事件 Active：App 在前台，并且在处理事件 Background：App 在后台，并且在执行代码 Suspended：App 在后台，没有执行代码。当 App 进入这个状态，App 不会接收到通知 大部分 App 状态改变都会调用相应的 App 代理方法： application:willFinishLaunchingWithOptions: - 在 App 的启动时间，这是你第一次可以执行自己的代码。 application:didFinishLaunchingWithOptions: - 在应用展示给用户之前，你可以在这个方法做最后的初始化操作。 applicationDidBecomeActive: - 当你的 App 从后台回到前台的时候会调用这个方法。 applicationWillResignActive: - 当你的 App 即将离开前台时，这个方法会被调用。 applicationDidEnterBackground: - 这时你的 App 运行在后台，并且可能在任意时间进入 Suspended 状态。在这里可以做一些清理操作，SDWebImage 就监听了这个通知，来做一些清理过期图片的操作。 applicationWillEnterForeground: - 你的 App 离开后台，即将进入前台，但是仍然没有进入 active 状态。 applicationWillTerminate: - 你的 App 将要结束。如果你的 App 此时处于 Suspended 状态，这个方法就不会调用。同样可以在这里做一些清理操作，SDWebImage 就监听了这个通知，来做一些清理过期图片的操作。 App Termination App 应该有随时被终止的准备，系统会回收处于 Suspended 状态的 App 的内存资源以便分配给新启动的 App 使用。处于 Suspended 状态的 App 被终止时，不会收到通知。App 处于 Background 状态，系统会在终止 App 之前调用 applicationWillTerminate: 代理方法。如果设备重启的话，系统仍然不会调用 applicationWillTerminate: 代理方法。 In addition to the system terminating your app, the user can terminate your app explicitly using the multitasking UI. User-initiated termination has the same effect as terminating a suspended app. The app’s process is killed and no notification is sent to the app. 这句没太理解。 Threads and Concurrency 多线程开发的几点建议： UI 的刷新始终要在主线程 消耗时间比较长的任务放在后台线程执行，例如：网络请求，文件处理等等 在启动时，尽量不要将任务放在主线程执行，只将与 UI 界面有关的初始化放在主线程，其他任务异步执行 For more see Concurrency Programming Guide. Related Link The App Life Cycle ","link":"https://lzhenhong.github.io/post/app-programming-guide-for-ios-the-app-life-cycle/"},{"title":"App Programming Guide for iOS - Expected App Behaviors","content":"这一篇主要是总结自己在看 App Programming Guide for iOS 的一些收获。大部分内容都是来自 App Programming Guide for iOS。 Xcode 创建的新项目能直接运行在真机和模拟器上，但是你需要做一些自定义才能提交到 App Store 和给用户提供好的体验。 Providing the Required Resources An Information property-list file：这个就是项目中的 info.plist 文件，这个文件中涉及了一些系统与你的 App 交互需要的信息。你可以直接编辑这个文件，也可以在你的项目 Info 选项页中进行编辑。 A declaration of app‘s required capabilities：每个应用都需要表明你的应用的运行环境。App Store 会根据这些信息来决定你的应用是否可以运行在用户的设备上。你可以在项目 Info 选项页的 Required device capabilities 入口来编辑。 One or more icons One or more launch images The App Bundle 当你编译 iOS App 的时候，Xcode 会将其打包成一个 bundle。一个典型的 App Bundle 包含以下内容： File Example Description App 可执行文件 MyApp 可执行文件包含你的编译代码，可执行文件的名称跟你的 App 除去扩展名一样 The information property list file Info.plist Info.plist 文件中包含 App 的配置信息，涉及了一些系统与你的 App 交互需要的信息。这个文件必须叫 Info.plist Storyboard files (or nib files) MainBoard.storyboard SB 包含需要展示的视图和控制器 Ad hoc distribution icon iTunesArtwork ？？？暂时不清楚 Settings bundle Settings.bundle 如果你想在系统 Settings app 展示自定义的页面，你就需要包含这个 Setting bundle，这个 bundle 包含 property list 和其他资源来自定义你的 setting 界面。 Preferences and Settings Programming Guide. The Information Property List File Xcode 会使用 General／Capabilities／Info 选项页的信息在编译期来生成 Info.plist 文件。这个文件被 App Store 和 iOS 系统使用来决定应用的运行环境和定位主要资源。 对于一些比较基本的选项，你可以在 General／Capabilities／Info 选项页来配置。如果 Xcode 没有提供图形化界面，你就需要在 Xcode property list 的编辑器提供正确的键值对。 Declare your app’s required capabilities in the Info tab：这个表明你的应用的最低运行系统，App Store 会用这个来避免比较低的系统来下载你的应用。 Apps that require a persistent Wi-Fi connection must declare that fact：这个对应 Info.plist 文件中的 UIRequiresPersistentWiFi 键，设置这个键对应的值为 YES 来避免 iOS 系统关闭活跃的 Wi-Fi 连接。所有使用网络的应用都推荐添加这个键。 Newsstand apps must declare themselves as such：在 Info.plist 文件中添加 UINewsstandApp 键来表明你的应用是在 Newsstand 应用中展示内容的。For more see iOS 杂志类应用开发 - NewsstandKit. Apps that define custom document types must declare those types：使用 Info 选项页的 Document Types 的选项来定义应用支持的文件的 UTI 和 icon。iOS 系统会使用这些信息决定你的应用是否能够处理特定的文件类型。For more see UIActivityViewController Tutorial: Sharing Data. Apps can declare any custom URL schemes they support：在 Info 选项页的 URL Types 选项来定义应用能处理的 URL Schemes。For more see Using URL Schemes to Communicate with Apps. Apps must provide purpose strings (sometimes called “usage descriptions”) for accessing user data and certain app features：当访问用户的隐私数据(位置、通讯录等等)时，你需要向用户申请权限。这样你就需要在 Info.plist 文件中描述你需要访问隐私数据的原因。如果你的应用在申请权限的时候没有提供对应的原因，App 会直接闪退。 Declaring the Required Device Capabilities 每个应用都需要表明最低支持的 iOS 操作系统。你可以在 Info.plist 文件中添加 UIRequiredDeviceCapabilities 键来表明应用额外的要求，这个键对应的值是字典／数组。 App Icons Xcode 在创建新项目的时候，会自动为应用的图标创建一个 image asset，Xcode 会在编译期在 Info.plist 文件添加相应的键值对。 App Launch (Default) Images 系统启动应用的时候会先显示启动图片，当你的应用准备好系统会移除启动图片。当应用从后台回到前台，如果你应用的 UI 截图可用，系统会使用你的截图。同样 Xcode 在创建新项目的时候，会自动为应用的启动图片创建一个 image asset，Xcode 会在编译期在 Info.plist 文件添加相应的键值对。 Supporting User Privacy 只有经过用户的同意应用才能访问用户的隐私数据。iOS 系统会保护 位置／联系人／日历事件／提醒事项／照片等等。你需要在 Info.plist 文件中提供访问隐私数据的原因，当你获取权限的时候，填写的原因会展示给用户看。在 iOS 10 之后你必须要在 Info.plist 文件中添加访问隐私数据的原因。 For more see Expected App Behaviors Table 1-2. Internationalizing Your App 为了国际化你的应用，你需要提供下列国际化的文件： Storyboard files Strings files Image files Video and audio files Related Link Expected App Behaviors ","link":"https://lzhenhong.github.io/post/app-programming-guide-for-ios-expected-app-behaviors/"},{"title":"反转链表","content":"背景：今天百度面试被问到线性链表的反转，哈哈哈哈哈 不会，数据结构算法之类的永远是心中的伤痛，自己慢慢想啊想，还是想出了一个比较 low 的解决方法，回到家自己上网搜了一下解决方法，有四种解决方法之多： 使用数组 使用 3 个指针（我想出了这个 😉😉） 插入法 递归 NBest 第一种：数组 使用数组比较简单，将单链表储存为数组，然后按照数组的索引逆序进行反转。 这里就不说了。 第二种：3 个指针 Node *list = createList(); Node *p, *q, *k; p = list-&gt;next; q = p-&gt;next; k = q-&gt;next; p-&gt;next = NULL; // 将第一个节点的 next 指针置空，代表新链表尾节点 while (k) { q-&gt;next = p; p = q; q = k; k = k-&gt;next; } q-&gt;next = p; // 最后两个节点，在循环外进行处理 list-&gt;next = q; // 将头节点的 next 指针指向新链表的首节点 更具体的分析可以看这里给出的链接。 🔗 第三种：插入法 这种方法就是将节点依次插入到头节点后面。 Node *list = createList(); Node *p = list-&gt;next; Node *q; while (p-&gt;next) { q = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next = list-&gt;next; list-&gt;next = q; } 了解思路加上画一些图，就能写出这些代码。 这里还可以新建另一个头节点，然后将链表的节点逐个插入头节点的后面，这样应该比上面要好实现一点。 第四种：递归 递归最难的一步就是将问题抽象出相似的子问题。 我们试想一下一个链表 A -&gt; B -&gt; C -&gt; D，要将这个链表反转，我们可以先将 B -&gt; C -&gt; D 反转，然后再将 A 与三个反转好的链表进行反转，这样就完成链表的反转。要 B-&gt; C -&gt; D 反转，我们可以先反转 C -&gt; D，然后再将 B 与反转好的 C 与 D 进行反转。这样看来我们就将问题抽象成相识的子问题。 static Node *newFisrtNode = NULL; Node *reverseLinkList(Node *list) { // 只有一个节点，直接返回，并且这里应该是新链表的第一个节点 if (!list || !list-&gt;next) { newFisrtNode = list; // 这里是新链表的第一个节点 return list; } Node *p = reverseLinkList(list-&gt;next); p-&gt;next = list; list-&gt;next = NULL; return list; } int main(int argc, const char * argv[]) { Node *list = createList(); reverseLinkList(list-&gt;next); list-&gt;next = newFisrtNode; Node *p = list-&gt;next; while (p) { printf(&quot;%d -&gt; &quot;, p-&gt;value); p = p-&gt;next; } return 0; } 这里其实还可以用栈来做，因为递归和栈基本上是可以互换使用的。 总结 这些代码中只考虑了一般情况，有一些特殊情况没有处理，例如：链表为空或者只有一个节点等。 通过这次面试也让我认识到了自己的不足： 因为自己的项目经历比较少，所以在 APP 结构的规划和设计存在很大的不足。 对一些知识点了解的不够透彻，只有一些模糊的印象。 一些 ObjC 和 iOS 底层知识点，自己也只是一知半解。 Last but not least. 数据结构和算法 😭😭。 By the way，一面与二面的面试官非常'赖斯'，十分感谢他们 🙏🙏。 相关链接 看图理解单链表的反转 ","link":"https://lzhenhong.github.io/post/fan-zhuan-lian-biao/"},{"title":"GCD 使用笔记","content":"在我年少无知的时候其实就已经写过一篇关于 GCD 的文章，自己现在拿出来看觉得有点羞愧，发现自己对 GCD 的认识基本上还是停留在一年前的水平，所以自己开始慢慢补上 GCD 的知识。 将以前写的东西拿出来充字数提醒自己。 任务 GCD 中要执行的操作都可以叫做任务(下载图片、下载文本等)。 队列 按照 FIFO (先进先出)的顺序帮我们调度任务，GCD 会把我们添加到队列中的任务取出，放到线程中执行。队列分为： 串行队列：串行队列同一时间只能有一个任务执行，后一个任务只有在前一个任务执行完之后才能被调度到线程中执行。 并行队列：并行队列同一时间可以多个任务执行，后一个任务不需要等前一个任务执行完，就可以被调度。 任务的提交 任务提交的方式会决定要不要 开启新的线程，在 GCD 中将任务添加到队列中有两种方式： 同步提交：将任务同步提交给队列，不会开启新的线程，只会在当前线程执行，并且只有在同步任务执行完之后，才能继续向下执行代码，同步提交的方式：dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); 异步提交：任务被异步提交给队列，会开启新的线程，但开多少新的线程，我们不能决定，由系统自己决定，并且不需要等异步任务执行完，就可以继续向下执行代码，异步提交的方式：dispatch_async(dispatch_queue_t queue, dispatch_block_t block); GCD 中不同的提交方式与不同队列的组合 串行队列同步提交 dispatch_queue_t queue = dispatch_queue_create(&quot;com.yys.test&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^{ // 下载文件，图片等资源 }); 首先根据同步提交 -&gt; 没有新的线程开启。 然后根据串行队列的特点 -&gt; 同一时间只能执行一个任务。 最终得到 -&gt; 不会开启新的线程，任务按照提交顺序在当前线程依次执行。 串行队列异步提交 dispatch_queue_t queue = dispatch_queue_create(&quot;com.yys.test&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ // 下载文件，图片等资源 }); 根据异步提交 -&gt; 会有新的线程开启。 根据串行队列的特点 -&gt; 同一时间只能执行一个任务。 最终得到 -&gt; 会开启新的线程，任务在新开启的线程中按照提交顺序依次执行，但是仅仅只会开启一条新的线程，因为异步提交会开启新的线程，但是串行队列只需要一条线程就可以执行所有提交的任务。 并行队列同步提交 dispatch_queue_t queue = dispatch_queue_create(&quot;com.yys.test&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^{ // 下载文件，图片等资源 }); 根据同步提交 -&gt; 没有新的线程开启。 并行队列 -&gt; 同一时间可以有多个任务被调度，但是在同步提交的条件下，并行队列失去了并行的能力，与串行队列区别不大。 最终得到 -&gt; 不会开启新的线程，提交的任务在当前线程按照提交顺序依次执行。 并行队列异步提交 dispatch_queue_t queue = dispatch_queue_create(&quot;com.yys.test&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ // 下载文件，图片等资源 }); 异步提交 -&gt; 可以开启新的线程。 并行队列 -&gt; 同一时间可以有多个任务被调度。 最终得到 -&gt; 有新的线程开启，可以多个任务同时执行，会开多条线程，但是开多少条线程我们不能控制。所以，可以用来同时下载多张图片。 GCD 中特别的队列：主队列(串行队列) 主队列是串行队列，它的主要作用就是用来更新 UI 控件，所有 UI 控件的刷新都必须在主线程中执行。 主队列同步提交 dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^{ // 下载文件，图片等资源 }); 主队列同步提交任务一定会发生死锁，就是线程被阻塞，不会再继续向下执行代码。 同步提交使用时尤其注意，不能在当前线程再向这个线程中提交任务。 主线程在执行任务 A，在任务 A 中向主队列中添加任务 B，这时任务 B 会在主线程中执行，由于主队列是串行队列，所以任务会依次执行，任务 A 执行完就会执行任务 B，但是任务 A 要执行完则任务 B 必须也要执行完，但是任务 B 要等任务 A 执行完才能执行，因此会发生死锁，代码不会向下执行。 主队列异步提交 dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^{ // 下载文件，图片等资源 }); 这一情况也是很特殊的，尽管是异步提交，但是没有新的线程开启，GCD会在恰当的时候把你提交的任务在主线程中执行完，执行的时刻不可控。 GCD 的其他用法 dispatch_after: 延后执行 dispatch_time_t time ＝ dispatch_time(DISPATCH_TIME_NOW, (int64_t)(需要延后的时间 * NSEC_PER_SEC)); dispatch_after(time, dispatch_get_main_queue(), ^{ // 需要延后执行的代码 }); NSLog(@&quot;线程执行开始&quot;); dispatch_async(dispatch_get_main_queue(), ^{ [NSThread sleepForTimeInterval:10.]; }); dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5. * NSEC_PER_SEC)); dispatch_after(time, dispatch_get_main_queue(), ^{ NSLog(@&quot;延后提交任务”); }); 需要注意的是，这里并不是在某一个时刻执行任务，只是将任务提交给队列。 执行结果： 这里第二次打印是在第一次打印10秒之后，并不是5秒之后。 dispatch_once: 只执行一次某段代码 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 只需要执行一次的代码 }); 需要注意的是 onceToken 一定要用 static 申明，这样才能保证需要执行一次的代码执行一次，否则的话，不能保证代码只执行一次，会出现难以修复的 bug。 dispatch_group 使用场景：当你执行多个异步任务，并且要等到所有的任务执行完做某些操作时 dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 提交任务A }); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 提交任务B }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 所有任务执行完后，所需要的操作 }); 这里有两种方式通知所有的任务完成： dispatch_group_notify 这一种是异步通知，不会阻塞当前线程(常用) dispatch_group_wait 这一种会一直等待，直到所有的任务完成或者超时 dispatch_barrier_sync 和 dispatch_barrier_async dispatch_barrier_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 提交任务 }); 这两个函数提交的任务，在执行时会阻塞后面的任务，在这一时间内，只有这一任务在执行，后续任务只有在这个任务执行完成后才能执行，并且所有在这个任务之前的任务一定会先于这个任务完成。 dispatch_barrier_sync 和 dispatch_barrier_async 只在自己创建的并发队列上有效，在全局并发队列、串行队列上，效果跟 dispatch_sync、 dispatch_async 效果一样。 ","link":"https://lzhenhong.github.io/post/gcd-shi-yong-bi-ji/"},{"title":"关于 enumerateObjectsUsingBlock 的小知识点","content":"在 StackOverflow 上看到 这篇讨论 的时候，让我发现了自己的盲区，所以写下这篇文章记录一下。 有一次在项目中使用的 enumerateObjectsUsingBlock 遍历数组的时候，使用了 return，当时没有多想，在 code review 的时候被同事指出，当时觉得不妥就改掉了，今天突然想起就去搜了一下。项目中好像没有直接跳出方法，而是执行到循环外面（这里的需求是当遍历到最后一个直接跳出循环，return 在 enumerateObjectsUsingBlock 相当于 continue，所以项目中会造成直接跳出循环）。 ObjC 中遍历容器数据 在 ObjC 中有好几种遍历容器数据的方式，这里讨论一下常用的三种。 C 语言风格 这种不需要多说，直接上代码 NSArray *names = @[@&quot;lzh&quot;, @&quot;ysh&quot;, @&quot;yys&quot;]; for (int i = 0; i &lt; names.count; ++i) { NSString *name = names[i]; NSLog(@&quot;%@&quot;, name); } ObjC 风格 这种相信会 ObjC 的人都会，也直接上代码。这里本质是使用了 NSFastEnumeration，在 这里 了解更多 NSArray *names = @[@&quot;lzh&quot;, @&quot;ysh&quot;, @&quot;yys&quot;]; for (NSString *name in names) { NSLog(@&quot;%@&quot;, name); } 在上面两种遍历中，我们还可使用 continue 和 break 来控制循环的跳转逻辑。 ObjC 中的 block 方式 我们看一下如何在 enumerateObjectsUsingBlock: 这里控制跳转逻辑 stop 参数的作用：停止遍历，但是会执行完 block 的代码才会退出循环 NSArray *names = @[@&quot;lzh&quot;, @&quot;ysh&quot;, @&quot;yys&quot;]; [names enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isEqualToString:@&quot;lzh&quot;]) { *stop = YES; // 这里并不会马上退出循环，而是执行完 block 中的代码才退出循环 } NSLog(@&quot;Name %@\\n&quot;, obj); }]; 运行结果： return 的作用：相当于前两种循环的 continue，会跳过此次循环 NSArray *names = @[@&quot;lzh&quot;, @&quot;ysh&quot;, @&quot;yys&quot;]; [names enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isEqualToString:@&quot;lzh&quot;]) { return; // 跳出此次循环 } NSLog(@&quot;Name %@\\n&quot;, obj); }]; 运行结果： 马上退出循环 NSArray *names = @[@&quot;lzh&quot;, @&quot;ysh&quot;, @&quot;yys&quot;]; [names enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj isEqualToString:@&quot;ysh&quot;]) { *stop = YES; return; // 立马跳出循环，并退出 } NSLog(@&quot;Name %@\\n&quot;, obj); }]; 运行结果： 补充循环遍历的了解 在看了 iOS 中集合遍历方法的比较和技巧 之后觉得自己对 ObjC 中的循环遍历还是了解的不好，决定再补上学到的知识。 其他几种循环遍历： makeObjectsPerformSelector KVC 集合运算符 enumerateObjectsUsingBlock enumerateObjectsWithOptions(NSEnumerationConcurrent) dispatch_apply 倒序遍历 NSArray *strings = @[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;]; for (NSString *string in [strings reverseObjectEnumerator]) { NSLog(@&quot;%@&quot;, string); } reverseObjectEnumerator 这个方法只会在循环第一次的调用。 [array enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(Sark *sark, NSUInteger idx, BOOL *stop) { [sark doSomething]; }]; 并发遍历 对于与顺序无关的遍历，我们可以使用并发来遍历容器数据。 block 枚举比 for 循环的好处 使用 block 来枚举时，block 内部会自动添加一个 autoreleasepool： [array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { // 这里有一个 @autoreleasepool 包围着 }]; 在普通 for 循环和 for-in 循环中没有，新版的 block 版本枚举器更加方便。for 循环中遍历产生大量 autorelease 变量时，就需要手动加局部 autoreleasepool。 总结 这篇文章没有什么含量，只是将自己不知道的知识点记录下来。😅😅 相关链接 What is the BOOL *stop argument for enumerateObjectsUsingBlock: used for? iOS 中集合遍历方法的比较和技巧 黑幕背后的Autorelease ","link":"https://lzhenhong.github.io/post/guan-yu-enumerateobjectsusingblock-de-xiao-zhi-shi-dian/"},{"title":"关于 UITableView 的滑动优化问题","content":"UITableView 应该是 iOS 开发中最重要的控件，当我们要展示多个相似的模型数据的时候，毫无疑问 UITableView 是最好的选择，Apple 已经将 UITableView 的优化做到非常极致了，满足我们简单的模型数据展示基本上是没有问题的。但是很多时候，我们展示的不是简简单单的文字数据，还有其他对性能消耗很大的数据，例如：图片等。在数据不多的情况下，遵循 UITableView 的标准使用方式就能满足要求。像 Twitter / Weibo 这样的数据模型很复杂，数量也很多的情况下，我们就需要通过各种手段来优化 UITableView 的滚动流畅度。 第一步 发现 UITableView 滑动不流畅之后，我们首先考虑的就是，给 UITableViewCell 的 estimatedRowHeight 属性设置值，或者实现 -tableView:estimatedHeightForRowAtIndexPath: 代理方法。 UITableView 在第一次显示的时候，会调用 -tableView:heightForRowAtIndexPath: 代理方法来获取所有 cell 的高度，以此确定 UITableView 的 contentSize。当我们的 cell 非常多，cell 的布局又非常复杂，计算高度需要耗费很多时间，此时 UITableView 的显示就会卡顿，我们给 UITableView 添加预设高度，UITableView 会利用这个预设高度来计算 UITableView 的 contentSize，而不是调用 -tableView:heightForRowAtIndexPath:，只有在 cell 要出现的时候才会去调用 -tableView:heightForRowAtIndexPath: 来获取真正的高度。 最近项目中用到了像 Instagram 发现页面，在进入详情页面之前，UITableView 需要滚动到指定位置。😆😆 So Easy! 在 -viewWillAppear: 调用 UITableView 的 -scrollToRowAtIndexPath:atScrollPosition:animated: 方法就好了，cmd+R 运行看效果，效果挺好，但是数据很多，在详情页面出现的时候会卡顿 1～2 秒，我们需要优化 UITableView，当然就是给 UITableView 设置预设高度，cmd+R，没有之前那么卡，还能接受，但是有个问题了，进入详情页面之后，UITableView 的 contentOffset 不对，我只是加了预设高度而已 😭😭。 👐👐 没办法只有万能的 Google 大法和 StackOverflow 大法能拯救我，查找了一大圈，在 这里 找到了答案，原因是在 -viewWillAppear: 方法中，UITableView 的 bounds 和 frame 都不确定，计算 UITableView 的 contentOffset 需要用到其中之一。解决办法就是在 -viewDidLayoutSubviews 方法中调用 UITableView 的 -scrollToRowAtIndexPath:atScrollPosition:animated: 方法。在 iOS 7 上我们还需要在 -viewDidLayoutSubviews 方法的末尾调用 [self.view layoutIfNeeded]; 来防止 iOS 7 上崩溃，在 这里 了解更多。 OK，已经处理到这样，应该没有问题了，运行程序，进入详情页面 UITableView 的位置没问题，项目这里有点赞的功能，问题又来了，点赞完之后需要刷新 UITableViewCell，这时我们能看到一个非常神奇的现象，就是刷新这一行 cell 之后，UITableView 会滚动一段距离。~~WTF，这是什么鬼。~~因为我们给的预设高度只是一个近似值，刷新 UITableView 貌似会使用到预设高度，而不是使用真正的高度，所以这里 UITableView 会滚动，同样 Google 了一大圈，都说将 cell 的高度缓存起来，然后在 -tableView:estimatedHeightForRowAtIndexPath: 方法中返回，正好项目中用到了 UITableView+FDTemplateLayoutCell 来计算 cell 的高度，计算完高度之后会缓存起来，我们就利用这个来设置 UITableView 的预设高度。使用一个 flag 来标记是否利用 UITableView+FDTemplateLayoutCell 来返回预设高度。大概的实现代码： - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:index inSection:0]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionNone animated:NO]; flag = NO; // flag 在 init 的时候设置为 YES [self.view layoutIfNeeded]; // fix iOS7 crash } - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { return [tableView fd_heightForCellWithIdentifier:identifier cacheByKey:uniqueCacheKey configuration:nil]; } // 给定固定的值会导致 tableView 在 reload 的时候出现跳跃问题 - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath { if (flag) { return 650.0; } // 这里的 identifier 和 cacheByKey 使用的值需要与上一个方法使用的值一致 return [tableView fd_heightForCellWithIdentifier:identifier cacheByKey:uniqueCacheKey configuration:nil]; } 更多关于 UITableView+FDTemplateLayoutCell，可以看这篇 优化UITableViewCell高度计算的那些事 博客，强烈推荐。 第二步 在初学的时候，我们经常会在这个 -tableView:cellForRowAtIndexPath: 数据源方法中绑定模型数据，这个方法调用的次数非常频繁，我们需要尽可能快的返回 UITableViewCell 实例。所以，我们尽量不在这个方法中绑定 cell 的模型数据，而在 -tableView:willDisplayCell:forRowAtIndexPath 代理方法中来绑定数据，这个方法会在 cell 显示之前调用。 第三步 这一步跟第二步几乎相同，就是在 -tableView:heightForRowAtIndexPath: 这个代理方法尽快返回，不要在这个方法中做太多的运算。 第四步 这一步主要是总结一些平常常用的优化技巧，这些都是我在网上看到的，感谢那些乐意分享知识的人。 Image Cache 将我们在 cell 上显示的 image 缓存起来，这个已经老生常谈了，而且做到这一步也不是特别困难 [UIImage imageNamed:@&quot;abc&quot;]; 这个是系统提供的方法，会在第一次引用这张图片的时候去应用的 main bundle 里加载适应屏幕分辨率的图片，并且系统会将这张图片缓存起来，之后再用这张图片就会使用缓存，而不用再去加载。但是这个方法会有一点小问题，就是你不能控制缓存图片的销毁，系统会在适当的时候来清除没有使用的图片数据。如果你只使用这个图片一次，之后就不会使用并且希望能马上释放，使用 imageWithContentsOfFile: 方法，这个方法不会在缓存中保存图片数据。 利用 ObjC 开发 iOS 的时候，加载网络图片通常用的是 SDWebImage，这个库会在内存中和磁盘中缓存图片资源，再次利用图片会优先在缓存中查找。PS: Swift 可以使用 Kingfisher。 AutoLayout 平常我们在编写 UI 布局的时候，一般有两个方法 纯代码手写：灵活多变，但是在编写复杂 UI 界面时，代码会非常冗长且没有什么意义。 利用 Xib 或者 StoryBoard：布局 UI 界面非常快，但是在多人合作的时候会有许多问题，因为每次打开这些文件就会更改内容，即使你什么都没做，所以你可能有许多冲突需要解决，并且这些文件的冲突还不好解决。这些文件本质上是 XML 文件，Xcode 将其识别为 UI 界面，但是我们解决冲突的时候是编辑 XML 文件，所以到底需要保留那一部分代码，常常让我们非常困惑。 抱歉说了这么多废话 😅😅 我们经常需要自定义 UITableViewCell 的子类，UITableViewCell 的布局有时会很复杂，因为要适配多种屏幕，所以，利用 Autolayout 无疑是挺好的选择，尤其是利用 Xib 和 SB 编写 UI 的时候。但是，当你的布局非常复杂同样会影响 UITableView 的滚动流畅度，因为系统需要花大量的时间去计算 UI 界面的布局，更具体的原因可以看 这里。当你想要将 UITableView 优化到极致，不妨可以考虑一下优化 AutoLayout。 Layer Opaque 尽量将 CALayer 的这个属性设为 YES，这样系统就不会渲染在这个 view 之后的 view，也不会将 view 与其混合。可以设置 cell 的 backgroundColor 属性，这个会跟系统自带的 highlight 冲突，因为系统自带的 highlight 依赖于透明度。当 cell 不可点击的时候，这样非常有用。 Row Height Cache 当 UITableViewCell 子类的布局非常复杂，计算高度就会很耗时，我们在计算过一次之后，就可以将高度数据缓存起来，等到再次需要的时候就直接从缓存中获取，而不需要再耗费时间去计算。再次推荐 UITableView+FDTemplateLayoutCell。 最后 这篇断断续续写了好几天，废话很多，主要记录自己的心得。非常感谢您能看到这。😘😘 不出意外的话，还会有一篇来记录 UITableView 的优化。 相关链接 Using Auto Layout in UITableView for dynamic cell layouts &amp; variable row heights Glassy Scrolling with UITableView How can I speed up a UITableView? ","link":"https://lzhenhong.github.io/post/guan-yu-uitableview-de-hua-dong-you-hua-wen-ti/"},{"title":"翻译篇 - Swift init()","content":"PS：翻译水平有限，推荐看原文 下载 Playgroung 文件 原文链接. 因为 Swift 的强类型和不可变性，所以就有规则防止你在一个对象完全初始化之前访问属性。 我不喜欢在一个函数体内做太多的事情，所以我会将初始化函数分成多个函数，这样问题就来了。 让我们假定你有一个这样的类： class Foo { let coreDataStack: CoreDataStack let mfpService = MFPService() let integrator: IntegrationService let flowController: FlowController let window: UIWindow } 这样的类需要许多行来初始化所有的属性，所以我们会将初始化逻辑分成多个函数，可能像这样： init(coreDataStack stack: CoreDataStack) { coreDataStack = stack integrator = setupIntegrator(stack, provider: mfpService) flowController = setupFlowController(stack) window = setupWindow(flowController.rootViewController) } 这仅仅是常规的重构... 猜一猜，这样不能通过编译： 这样显得不那么 Cool. :] 我在 Twitter 上跟一些能干的人交流，寻找一些选择，下面是我觉得挺好的。 让我们来看一下这些选择 选择 1 - 对可选变量隐式解包 var integrator: IntegrationService! 这个选择经常会出错，我们选择 Swift 是因为它能写出更安全的代码。 请不要这样写。 选择 2 - 有副作用的懒加载 我们用隐藏的懒加载属性，但是可能会有副作用 class Foo_lazy { let coreDataStack: CoreDataStack let mfpService = MFPService() init(coreDataStack stack: CoreDataStack) { coreDataStack = stack let _ = integrator let _ = rootFlowController let _ = window } lazy var rootFlowController: FlowController = { return FlowController(coreDataStack: self.coreDataStack) }() lazy var window: UIWindow = { let window = UIWindow(frame: UIScreen.mainScreen().bounds) window.backgroundColor = UIColor.whiteColor() window.rootViewController = self.rootFlowController.rootViewController window.makeKeyAndVisible() return window }() lazy var integrator: IntegrationService = { let coreDataProcessor = CoreDataReportProcessor(stack: self.coreDataStack) let integrator = IntegrationService(provider: self.mfpService) { coreDataProcessor.processReports($0) } return integrator }() } 这个解决方法允许我们将代码分开，并且也运行得很好，但是这样也不是那么好，因为 属性不是真正的不可变，我们可以将其定义成隐私，如此不能在外面更改它们，但是他们仍然是可变的。 我不喜欢像这样会触发副作用的代码，这样看起来很不整洁。 选择 3 - 隐私的静态方法 我们可以定义隐私的静态方法，用它们来初始化属性(并且可以将它们放在隐私的类扩展中)： class Foo_ext { let coreDataStack: CoreDataStack let mfpService = MFPService() let integrator: IntegrationService let flowController: FlowController let window: UIWindow init(coreDataStack stack: CoreDataStack) { coreDataStack = stack integrator = Foo_ext.SetupIntegrator(stack, provider: self.mfpService) flowController = Foo_ext.SetupFlowController(stack) window = Foo_ext.SetupWindow(self.flowController.rootViewController) } } private extension Foo_ext { static func SetupIntegrator(stack: CoreDataStack, provider: Provider) -&gt; IntegrationService { let coreDataProcessor = CoreDataReportProcessor(stack: stack) let integrator = IntegrationService(provider: provider) { coreDataProcessor.processReports($0) } return integrator } static func SetupFlowController(stack: CoreDataStack) -&gt; FlowController { return FlowController(coreDataStack: stack) } static func SetupWindow(controller: UIViewController) -&gt; UIWindow { let window = UIWindow(frame: UIScreen.mainScreen().bounds) window.backgroundColor = UIColor.whiteColor() window.rootViewController = controller window.makeKeyAndVisible() return window } } 这是我现在最喜欢的方式： 确保不可变的属性 不会有副作用 非常整洁并且不会有编译错误 总结 还有一些 Twitter 上的朋友推荐的其他方法，你可以在这里找到 我也是才刚刚开始学 Swift，我必须说我越来越喜欢它，尤其是 Swift 2.0。 在有了20年的编程经历之后，重新变成新手很有趣，幸运的是，我们有伟大的愿意分享知识的社区。 非常感谢 @jessyMeow 和 @KostiaKoval 指出比我原来方法更好的方法 😃 如果你有你喜欢的方法，请在 Twitter 上让我知道，我很愿意学习！ Follow @merowing_ on Twitter ","link":"https://lzhenhong.github.io/post/fan-yi-pian-swift-init/"},{"title":"详解 property","content":"在利用 Objective-C 的开发中，我们需要创建许多的类，类包括成员变量和成员方法／类方法 (Objective-C 中没有类成员变量)。但是大部分 Obj-C 的类文件中都看不到成员变量的申明，我们更多看到的是形如： @property (nonatomic, copy) NSString *name; 。这是因为当我们这样写之后，Xcode 会自动为我们添加成员变量，并生成相应成员变量的存取方法。 手动编写成员变量／存取方法 @interface XYDog: NSObject { NSString *_name; } - (void)setName:(NSString *)name; - (NSString *)name; @end @implementation XYDog - (void)setName:(NSString *)name { _name = [name copy]; } - (NSString *)name { return _name; } @end Xcode 自动生成 @interface XYDog: NSObject @property (nonatomic, copy) NSString *name; @end @implementation XYDog @end 仅通过 @property，Xcode 就自动生成手动编写的代码，这大大提高了开发效率。 @property 之后的关键字 原子性：默认情况下，编译器合成的方法会通过锁定机制保证原子性 atomic：加锁，使用同步锁的开销较大，iOS 开发一般情况下不会用此关键字，Mac OS X 开发使用该关键字不会有性能瓶颈。 nonatomic：不加锁。 读/写权限： readwrite：同时具有 getter 和 setter。 readonly：只有 getter。 内存管理： assign：只针对 「储量类型」 的简单赋值操作 (int／double／CGFloat／CGRect)。 strong：为这种属性设置新值时，setter 会 retain 新值，release 旧值，再将新值设置给实例变量。 weak：为这种属性设置新值时，setter 不会 retain 新值，也不会 release 旧值，当引用的对象被释放时，该属性会被自动设为 nil。 unsafe_unretained：与 assign 相同，适用于对象类型，不会 retain 引用的对象，引用的对象被销毁后，不会被自动设为 nil。 copy：为这种属性设置新值时，不会 retain 新值，而会将其拷贝一份，在设置给实例变量。当属性类型为 NSString * 时，经常用这个关键字。 方法名： getter= 指定获取方法名，@property (nonatomic, assgin, getter=isOn) BOOL on; setter= 指定设置方法名。 自己申明成员变量 这是不是意味我们就不需要再关心成员变量的创建了？并不是。Xcode 在某些情况下，不会生成成员变量： 重写了 readonly 属性的 getter 重写了 readwrite 属性的 setter 和 getter 在 .m 文件中用 @dynamic 标记的属性 在这些情况下，Xcode 会认为我们自己要管理成员变量，所以就不会合成成员变量。 在这几种情况下，假如我们需要成员变量的话，就得自己申明成员变量，这里有两种方法： 第一种 @interface XYDog: NSObject @property (nonatomic, readonly) NSString *name; @end @implementation XYDog { NSString *_name; } - (NSString *)name { if (![_name isEqualToString:@&quot;yys&quot;]) { return @&quot;lzh&quot;; } return _name; } @end 第二种 @interface XYDog: NSObject @property (nonatomic, readonly) NSString *name; @end @implementation XYDog @synthesize name = _name; - (NSString *)name { if (![_name isEqualToString:@&quot;yys&quot;]) { return @&quot;lzh&quot;; } return _name; } @end 这种方法还是告诉 Xcode 帮我们合成成员变量。 注意事项 我们访问成员变量的通常用的是形如 dog.name 的点语法，这不是 Objective-C 语言的特性，而是 Xcode 特性，Xcode 会把这样的语法翻译成调用 setter 或者 getter，因此我们能获得或者设置成员变量的值。 直接访问成员变量的语法是 dog-&gt;name，Objective-C 对象本质上是 C 语言的结构体，所有这里就是访问结构体的成员变量。同样在 .m 文件中用 _name 访问同样也是直接访问成员变量。 我们在 .m 文件中重写 setter 和 getter 方法时，有几点需要注意： 不要在 getter 中使用形如 self.name 的语句来访问成员变量，Xcode 会将这个翻译成 getter 方法的调用，这里就会造成死循环。 同样不要在 setter 中使用形如 self.name = @&quot;Jerry&quot;; 的语句来设置成员变量的值，原因同上。 我们应该使用 _name 或者 _name = @&quot;xxx;&quot; 来访问和设置成员变量的值。 ","link":"https://lzhenhong.github.io/post/xiang-jie-property/"}]}